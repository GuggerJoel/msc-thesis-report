\chapter{Implementation in Bitcoin-core secp256k1}
\label{chap:implementation-secp256k1}

As mentionned before, Bitcoin use eliptic curve cryptography (ECC) for signing transactions.
When the first release of Bitcoin core appeared in the early 2009, the cryptographic
computations was performed with the OpenSSL library. Some years after a project
started with the goal of replacing OpenSSL and creating a custom and minimalistic
library for cryptography over the curve secp256k1. This library is now available
on GitHub at \texttt{bitcoin-core/secp256k1} project and it is one of the most optimized,
if not the most optimized, library for the curve secp256k1. It is worth noting that
this library is also used by other major crypto-currencies like Ethereum, so extending
the capabilities of this library is a good choice to attract other cryptographer
to have a look and increase the amount of reviews for this thesis.

The implementation is spread into four main components: (i) a DER parser-serializer,
(ii) a textbook implementation of Paillier homomorphic cryptosystem, (iii) an
implementation of the Zero-Knowledge Proofs adaptation, and (iv) the threshold
public API. It is worth noting that the current implementation is NOT production
ready and NOT side-channel attack resistant. Paillier and ZKP are not constant
time computation and use \texttt{libgmp} for all arithmetic computations, even
when secret values are used. This implementation is a textbook implementation
of the scheme and need to be reviewed and more tested before been used in production.

\minitoc

\newpage

% -----------------------------------------------------------------------------
\section{Configuration}

The library use \texttt{autotools} to manage the compilation, installation and
uninstallation. A system of module is already present in the structure with an
ECDH experimental module for shared secret computation and a recovery module for
recover ECDSA public key. A module can be flag as experimental, then, at the
configuration time, an explicit parameter enabling experimental modules must be
passed and a warning is showed to warn that the build contains experimental code.

\subsection{Add experimental module}

In this structure, the threshold extension is all indicated to be an experimental
module also. A new variable \texttt{\$enable\_module\_recovery} is declared
with a m4 macro defined by autoconf in the
\texttt{configure.ac} file with the argument \texttt{-{}-enable-module-threshold}.
The default value is set to \texttt{no}.

\begin{listing}
  \bashfile[firstline=137,lastline=140]{02-main/listings/configure.ac}
	\caption{Add argument into \texttt{configure.ac} to enable the module}
	\label{lst:configureEnableThreshold}
\end{listing}

If the variable \texttt{\$enable\_module\_recovery} is set to yes into \texttt{configure.ac}
(lines 443 to 445) a compiler constant is declared, again with a m4 marco defined by
autoconf, and set to 1 in \texttt{libsecp256k1-config.h}
(lines 20 and 21.) This header file is generated when \texttt{./configure} script is run and
is included in the library.

\begin{listing}
  \bashfile[firstline=443,lastline=445]{02-main/listings/configure.ac}
  \cfile[firstline=20,lastline=21]{02-main/listings/libsecp256k1-config.h}
	\caption{Define constant \texttt{ENABLE\_MODULE\_THRESHOLD} if module enable}
	\label{lst:defineEnableThreshold}
\end{listing}

The main file \texttt{secp256k1.c} (lines 586 to 590) and the tests file \texttt{tests.c}
include headers based on the compiler constant definition.

\begin{listing}
  \cfile[firstline=586,lastline=590]{02-main/listings/secp256k1.c}
	\caption{Include implementation headers if \texttt{ENABLE\_MODULE\_THRESHOLD} is
  defined}
	\label{lst:includeThresholdImplementationHeaders}
\end{listing}

The module is set to experimental to avoid enabling it without explicitly agree
to build experimental code. If experimental is set to yes a warning is display
during the configuration process, if experimental is not set and any experimental
module is enable an error message is display and the process failed.

\begin{listing}
  \bashfile[firstline=465,lastline=482]{02-main/listings/configure.ac}
	\caption{Set threshold module to experimental into \texttt{configure.ac}}
	\label{lst:setModuleExperimental}
\end{listing}

\subsection{Configure compilation}

A module is composed of one or many \texttt{include/} headers that
contain the public API with a small description of each functions, these headers
are copied in the right folders when \texttt{sudo make install} command is run.
The file \texttt{Makefile.am} define which headers need to be installed, which
not and how to compile the project. This file is parsed by autoconf to generate
the final \texttt{Makefile} with all the fonctionalities expected.

Each module has its own \texttt{Makefile.am.include} which describe what to do
with all the files present into the module folder. This file is included in the
main \texttt{Makefile.am} (lines 179 to 181) if the module is enable.

\begin{listing}
  \makefile[firstline=179,lastline=181]{02-main/listings/Makefile.am}
	\caption{Include specialized Makefile if threshold module is enable}
	\label{lst:includeSpecializedMakefile}
\end{listing}

The specialized \texttt{Makefile.am.include} declare the header requisite to be
include and declare the list of all the headers that must not be installed on
the system when \texttt{sudo make install} command is run.

\begin{listing}
  \makefile{02-main/listings/Makefile.am.include}
	\caption{Specialized Makefile for threshold module}
	\label{lst:specializedMakefile}
\end{listing}

It is possible to build the library and enable the threshold module with the
command below.

\begin{minted}[breaklines=true,fontsize=\scriptsize]{bash}
  ./configure --enable-module-threshold --enable-experimental
\end{minted}

% -----------------------------------------------------------------------------

\section{DER parser-serializer}

Transmit messages and retreive keys are an important part of the scheme. Because
between all steps a communication on the network is necessary, a way to export and
import data is required. Bitcoin private key are simple structures because of the
fixed curve and their intrinsic nature, a single $2^{256}$ bits value. Threshold
private key are composed of multiple parts like: (i) the private share, (ii) a
Paillier private key, (iii) a Paillier public key, and (iv) Zero-Knowledge Proof
parameters. To serialize these complex structures the DER standard has been choosed.
Three simple data types are implemented in the library: (i) sequence, (ii) integer,
and (iii) octet string.

\subsection{Sequence}

The sequence data structure holds a sequence of integers and/or octet strings. The
sequence start with the constant \texttt{0x30} and is followed by the content lenght
and the content itself.
A lenght could be in the short form or the long form. If the content number of bytes
is shorter to \texttt{0x80} the lenght byte indicate the lenght, if the content
is equal or longer than \texttt{0x80} the seven lower bits 0 to 6 where
$\texttt{byte} = \{ \texttt{b}_7, \dots, \texttt{b}_1, \texttt{b}_0\}$
indicate the number of followed bytes which are used for the lenght.

\begin{listing}
  \cfile[firstline=10,lastline=23]{02-main/listings/der_impl.h}
	\caption{Implementation of a DER lenght parser}
	\label{lst:implDERLenghtParser}
\end{listing}

The sequence parser check the first byte with the constant \texttt{0x30} and
extract the content lenght. Position in the input array are holds in the \texttt{*pos}
variable, extracted lenght is stored in \texttt{*lenght}, and the offset holds
how many bytes in the data are used for the header and the lenght. A coherence
check is performed to ensure that the current offset and the retreived lenght
result to the same amount of bytes passed in argument.

When a sequence holds other sequence, retreive their total lenght (including header
and content lenght bytes) is needed to recursivly parse them. A specific function
is created to retreive the total lenght of a struct given a pointer to its first
byte.

\begin{listing}
  \cfile[firstline=25,lastline=35]{02-main/listings/der_impl.h}
	\caption{Implementation of a DER sequence parser}
	\label{lst:implDERSequenceParser}
\end{listing}

The serialization of a sequence is implemented as a serialization of an octet string
with the sequence header \texttt{0x30} without integrity check of the content.
The content lenght is serialized first, then the header is added.

The result of a content lenght serialization can be $\geq 1$ byte-s. If the content
is shorter than \texttt{0x80}, then one byte is enough to store the lenght. Else
multiple bytes ($\geq 2$) are used. Because the number of byte is undefined before
the computation a memory allocation is necessary and a pointer is returned with
the lenght of the array.

\begin{listing}
  \cfile[firstline=155,lastline=166]{02-main/listings/der_impl.h}
	\caption{Implementation of a DER sequence serializer}
	\label{lst:implDERSequenceSerializer}
\end{listing}

If the content lenght is longer than \texttt{0x80}, then \texttt{mpz} is used to serialize
the lenght into a bytes array in big endian most significant byte first. The lenght
of this serialization is stored into \texttt{longsize} and is used to create the
first byte with the most significant bit set to 1 (line 93).

\begin{listing}
  \cfile[firstline=81,lastline=100]{02-main/listings/der_impl.h}
	\caption{Implementation of a DER lenght serializer}
	\label{lst:implDERLenghtSerializer}
\end{listing}

\subsection{Integer}

Integers are used to store the most values in the keys and Zero-Knowledge Proofs.
An integer can be positive, negative or zero and are represented in the second
complement form. The header start with \texttt{0x02}, followed by the lenght of the data.
Parsing and serializing integer are already implemented in libgmp, functions are
juste wrapper to extract information from the header and start the \texttt{mpz}
importation at the right offset.

\subsection{Octet string}

Octet strings are used to holds serialized data like points/public keys.
An octet string is an arbitrary array of bytes. The header start with \texttt{0x04}
followed by the size of the content. The serialization implementation retreive
the lenght of the content, copy the header and the octet string into a new memory
space, and return the pointer with the total lenght. The parser implementation
copy the content and set the conent lenght, the position index, and the offset.


\section{Paillier cryptosystem}

Homomorphic encryption is required in the scheme and Paillier is proposed in the
white paper. Paillier homomorphic encryption is simple to implement in a textbook
way, but this implementation is not optimized and need to be reviewed.

\subsection{Data structures}

Encrypted message, public and private keys are transmited. As mentionned before,
the DER standard format is used to parse and serialize data. DER schema for all
data structures are defined to ensure portability over different implementations.

\subsubsection{Public keys}

The public key is composed of a public modulus and a generator. The implementation
data structure add a big modulus corresponding to the square of the modulus. A
version number is added for futur compatibility purposes.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{text}
    HEPublicKey ::= SEQUENCE {
        version           INTEGER,
        modulus           INTEGER,  -- p * q
        generator         INTEGER   -- n + 1
    }
  \end{minted}
	\caption{DER schema of a Paillier public key}
	\label{lst:DERSchemaPaillierPub}
\end{listing}

libgmp is used for all the arithmetic in Paillier implementation, all numbers are
stored in \texttt{mpz\_t} type. The parser take in input an array of bytes with a
lenght and the public key to fill.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{c}
    typedef struct {
        mpz_t modulus;
        mpz_t generator;
        mpz_t bigModulus;
    } secp256k1_paillier_pubkey;

    int secp256k1_paillier_pubkey_parse(
        secp256k1_paillier_pubkey *pubkey,
        const unsigned char *input,
        size_t inputlen
    );
  \end{minted}
	\caption{DER parser of a Paillier public key}
	\label{lst:DERImplPaillierParsePub}
\end{listing}


\subsubsection{Private keys}

The private key is composed of a public modulus, two primes, a generator, a
private exponant $\lambda = \varphi(n) = (p-1)(q-1)$, and a private coefficient
$\mu = \varphi(n)^{-1} \mod n$. Again, a version number is added for futur
compatibility purposes.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{text}
    HEPrivateKey ::= SEQUENCE {
        version           INTEGER,
        modulus           INTEGER,  -- p * q
        prime1            INTEGER,  -- p
        prime2            INTEGER,  -- q
        generator         INTEGER,  -- n + 1
        privateExponent   INTEGER,  -- (p - 1) * (q - 1)
        coefficient       INTEGER   -- (inverse of privateExponent) mod (p * q)
    }
  \end{minted}
	\caption{DER schema of a Paillier private key}
	\label{lst:DERSchemaPaillierPriv}
\end{listing}

The parser take in input an array of bytes with a lenght and the private key to fill.
The big modulus is computed after the parsing to accelerate encryption and decryption.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{c}
    typedef struct {
        mpz_t modulus;
        mpz_t prime1;
        mpz_t prime2;
        mpz_t generator;
        mpz_t bigModulus;
        mpz_t privateExponent;
        mpz_t coefficient;
    } secp256k1_paillier_privkey;

    int secp256k1_paillier_privkey_parse(
        secp256k1_paillier_privkey *privkey,
        secp256k1_paillier_pubkey *pubkey,
        const unsigned char *input,
        size_t inputlen
    );
  \end{minted}
	\caption{DER parser of a Paillier private key}
	\label{lst:DERImplPaillierParsePriv}
\end{listing}

\subsubsection{Encrypted messages}

An encrypted message with Paillier cryptosystem is a big number $\in [0, n^2]$.
No version number is added in this case.
The implementation structure contain a nonce value that could be set to 0
to stores the nonce used during encryption.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{text}
    HEEncryptedMessage ::= SEQUENCE {
        message           INTEGER
    }
  \end{minted}
	\caption{DER schema of an encrypted message with Paillier cryptosystem}
	\label{lst:DERSchemaPaillierEncMessage}
\end{listing}

An encrypted message can be serialized and parsed, encrypted messages are used in
messages exchange during the signing protocol by both actors.

% \begin{listing}
%   \begin{minted}[breaklines=true,fontsize=\scriptsize]{c}
%     int secp256k1_paillier_message_parse(
%         secp256k1_paillier_encrypted_message *message,
%         const unsigned char *input,
%         size_t inputlen
%     );
%
%     unsigned char* secp256k1_paillier_message_serialize(
%         size_t *outputlen,
%         const secp256k1_paillier_encrypted_message *message
%     );
%   \end{minted}
% 	\caption{DER serializer-parser of encrypted messages with Paillier}
% 	\label{lst:DERImplPaillierEncMessage}
% \end{listing}

\subsection{Encrypt and decrypt}

The message $0 \leq m < n$ to encrypt is \texttt{m}, a random value $r$ where
$0 \leq r < n$ is selected with the fonction pointer \texttt{noncefp} and put into
the nonce value of the result encrypted message. The cipher
$c = g^m \cdot r^n \mod n^2$ is put into \texttt{res->message}.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{c}
    int secp256k1_paillier_encrypt_mpz(secp256k1_paillier_encrypted_message *res, const mpz_t m, const secp256k1_paillier_pubkey *pubkey, const secp256k1_paillier_nonce_function noncefp) {
        mpz_t l1, l2, l3;
        int ret = noncefp(res->nonce, pubkey->modulus);
        if (ret) {
            mpz_inits(l1, l2, l3, NULL);
            mpz_powm(l1, pubkey->generator, m, pubkey->bigModulus);
            mpz_powm(l2, res->nonce, pubkey->modulus, pubkey->bigModulus);
            mpz_mul(l3, l1, l2);
            mpz_mod(res->message, l3, pubkey->bigModulus);
            mpz_clears(l1, l2, l3, NULL);
        }
        return ret;
    }
  \end{minted}
	\caption{Implementation of encryption with Paillier cryptosystem}
	\label{lst:implEncryptPaillier}
\end{listing}

The cipher $c \in \mathbb{Z}_{n^2}^*$ is decrypted with
$m = L(c^{\lambda} \mod n^2) \cdot \mu \mod n$ where $L(x) = (x - 1) / n$.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{c}
    void secp256k1_paillier_decrypt(mpz_t res, const secp256k1_paillier_encrypted_message *c, const secp256k1_paillier_privkey *privkey) {
        mpz_t l1, l2;
        mpz_inits(l1, l2, NULL);
        mpz_powm(l1, c->message, privkey->privateExponent, privkey->bigModulus);
        mpz_sub_ui(l2, l1, 1);
        mpz_cdiv_q(l1, l2, privkey->modulus);
        mpz_mul(l2, l1, privkey->coefficient);
        mpz_mod(res, l2, privkey->modulus);
        mpz_clears(l1, l2, NULL);
    }
  \end{minted}
	\caption{Implementation of decryption with Paillier cryptosystem}
	\label{lst:implDecryptPaillier}
\end{listing}

\subsection{Homomorphism}

$D(E(m_1, r_1)^{m_2} \mod n^2) = m_1 m_2 \mod n$

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{c}
    void secp256k1_paillier_mult(secp256k1_paillier_encrypted_message *res, const secp256k1_paillier_encrypted_message *c, const mpz_t s, const secp256k1_paillier_pubkey *pubkey) {
        mpz_powm(res->message, c->message, s, pubkey->bigModulus);
        mpz_set(res->nonce, c->nonce);
    }
  \end{minted}
	\caption{Implementation of homomorphic multiplication with Paillier cryptosystem}
	\label{lst:implDecryptPaillier}
\end{listing}

$D(E(m_1, r_1) \cdot E(m_2, r_2) \mod n^2) = m_1 + m_2 \mod n$ or $D(E(m_1, r_1) \cdot g^{m_2} \mod n^2) = m_1 + m_2 \mod n$

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{c}
    void secp256k1_paillier_add(secp256k1_paillier_encrypted_message *res, const secp256k1_paillier_encrypted_message *op1, const secp256k1_paillier_encrypted_message *op2, const secp256k1_paillier_pubkey *pubkey) {
        mpz_t l1;
        mpz_init(l1);
        mpz_mul(l1, op1->message, op2->message);
        mpz_mod(res->message, l1, pubkey->bigModulus);
        mpz_clear(l1);
    }
  \end{minted}
	\caption{Implementation of homomorphic addition with Paillier cryptosystem}
	\label{lst:implDecryptPaillier}
\end{listing}


\section{Zero-knowledge proofs}
\lipsum[1-2]

\section{Threshold module}
\lipsum[1-2]
