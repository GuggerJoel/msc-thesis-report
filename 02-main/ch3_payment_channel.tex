\chapter{Payment channels, a micropayment network}
\label{chap:paymentChannels}

Payment channels or micropayment channels, as mentioned previously, are one part
of the scalability solution. There are various propositions to construct
such structures. To have a better understanding of the differences, strengths, and
weaknesses of some of them the author proposes a classification and definitions
in the white paper in the following appendices. Those definitions are repeated starting
now.

\begin{definition}[Trustless]
  A channel is trustless if and only if the safety of funds for every player
  $p_i \in \mathcal{P} = \{\mathcal{P}_0, \dots, \mathcal{P}_n\}$
  at each step $\mathcal{S}$ of the protocol does not depend on
  player $\Delta p = \mathcal{P} - p_i$'s behavior.
\end{definition}

\begin{definition}[Optimal]
  A channel is optimal if and only if the number of transactions $\mathcal{T}(\mathcal{C})$
  needed to claim the funds for a given constraint $\mathcal{C}$ is equal to
  the number of moves $\mathcal{M}(\mathcal{C})$ needed to satisfy the constraint
  at any time without breaking the first definition.

  For a constraint $\mathcal{C}$ in a channel $\mathcal{P}_1 \rightarrow \mathcal{P}_2$,
  refunding $\mathcal{P}_1$ requires $\mathcal{M}(\mathcal{C}) = 1$, thus
  an optimal scheme requires $\mathcal{T}(\mathcal{C}) = \mathcal{M}(\mathcal{C}) = 1$.
  Note: in a channel $\mathcal{P}_1 \rightarrow \mathcal{P}_2$ refund and settlement both
  require $\mathcal{M}(\mathcal{C}) = 1$.
\end{definition}

\begin{definition}[Endless]
  A channel is endless if and only if there is no predetermined lifetime at the setup.
\end{definition}

\begin{definition}[Pulseless]
  A channel is pulseless if and only if there is no need to refresh or close the
  channel on-chain while at least one player $p_i \in \mathcal{P} = \{\mathcal{P}_0,
  \dots, \mathcal{P}_n\}$ where the available amount to send is $A(p_i) > 0$. By
  definition a pulseless channel must be also endless.
\end{definition}

\begin{definition}[Undelayed]
  A channel is undelayed if and only if each player $p_i \in \mathcal{P} = \{\mathcal{P}_0,
  \dots, \mathcal{P}_n\}$ can trigger the process to get their money back at any time.
\end{definition}

These definitions are used in the following to compare different commonly
exposed payment channel constructions. It is worth noting that the list does not
contain all the payment channel propositions and some of them might be missing.
However, the list contains a fairly good representation of the different types
existing.

\minitoc

\newpage

% -----------------------------------------------------------------------------
\section{Types of payment channel}

We can distinguish two type of channels, the unidirectional channel that allows
one user to send money to another user in a channel and the bidirectional
channel that allows two users to send in either direction in a channel. Usually, a
bidirectional channel is more optimal than two unidirectional channels.

\subsection{Unidirectional}

In unidirectional channels, there is a payer, later referred to as player-one or
client, and a payee, later referred to as player-two or provider.  It is not
possible to transfer money back in the reverse direction in the channel.

\subsubsection{Spilman-style payment channels}

Spilman-style payment channels, proposed by Jeremy Spilman in 2013
\cite{SpilmanStyle}, are the most simple construction of a unidirectional
payment channel. They have a finite lifetime predefined at the setup phase and
the client, i.e., the payer, cannot trigger their refund before the end of the
channel lifetime (but he can receive his funds back if the payee settles the
channel before the end of the lifetime). The channel is one-time use. When the
payer or the payee get their funds, the channel is closing. Neither the payer nor the
payee need to watch the blockchain to react to events during the lifetime of
the channel because only the payee can broadcast a transaction, so both do not
need to watch the blockchain to be safe. It is worth noting that, without a
proper fix to transaction malleability \cite{SegWitBIP, BIP62,
DBLP:journals/corr/AndrychowiczDMM13, DBLP:journals/corr/DeckerW14}, this scheme
is not secure.

According to the previous definitions, Spilman-style payment channels are
trustless (assuming that a suitable solution for transaction malleability has
been implemented), and optimal but not endless nor undelayed.

\subsubsection{CLTV-style payment channels}

Introduced in 2015, CLTV-style payment channels are a solution to the malleability
problem in Spilman-style payment channels. With the new \texttt{OP\_CODE} check
locktime verify (\texttt{OP\_CHECKLOCKTIMEVERIFY}), redefining the
\texttt{OP\_NOP2}, it is possible to enforce the non-spending of a transaction
output until some time in the future. With \texttt{OP\_CHECKLOCKTIMEVERIFY} a
transaction output can enforce the spending transaction to have a
\texttt{nLockTime} later or equal to the specified value in the script
\cite{BIP65}.

Instead of creating a funding transaction and a refund transaction vulnerable to
transaction malleability attacks, the client creates the funding transaction
output with a script that allows the provider and the client to spend the funds
with co-operation or, after a lock time, the client can spend the funds without
the co-operation of the provider.

CLTV-style payment channels have the same properties as Spilman-style payment
channels following the previous definition but are not subject to transaction
malleability attacks.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{text}
IF
    <provider pubkey> CHECKSIGVERIFY
ELSE
    <expiry time> CHECKLOCKTIMEVERIFY DROP
ENDIF
<client pubkey> CHECKSIG
  \end{minted}
	\caption{Locking script (scriptPubKey) with \texttt{CHECKLOCKTIMEVERIFY}}
	\label{lst:scriptPubKeyCLTV}
\end{listing}

\subsection{Bidirectional}

In a bidirectional channel $\mathcal{C}$, the player $A$ and the player $B$ can
send funds in direction $\mathcal{C}_{AB}$ and $\mathcal{C}_{BA}$. A
bidirectional channel can be a specific scheme or a pairing of existing
unidirectional channels.

\subsubsection{Decker-Wattenhofer duplex payment channels}

Decker-Wattenhofer duplex payment channels \cite{Decker2015fast}, also called
\gls{dmc}, proposed in 2015, are bidirectional channels based on pairs of
Spilman-style unidirectional channels. The construction has a finite lifetime
predefined at the setup phase but can be refreshed on-chain to keep the channel
open with an updated state. During the refresh process, it is possible to refill
the channel, and the scheme allows payment routing with \gls{htlc}.

Duplex payment channels are trustless and endless, but not optimal. The
uncooperative close of the channel requires $d + 2$ transactions. They are not
pulseless (it requires a refresh transaction when the lifetime runs over, to keep
the channel open) and not undelayed (without other players cooperation the funds are
recovered after \texttt{nLockTime} values).

\subsubsection{Poon-Dryja payment channels}

Poon-Dryja payment channels, also called Lightning Network, is a proposed
implementation of \gls{htlc} with bidirectional payment channels which allow
payments to be securely routed across multiple peer-to-peer payment channels
\cite{poon2016bitcoin}.

Their scheme is trustless (assuming that \gls{segwit} has been implemented),
endless, pulseless, and undelayed but not optimal when the channel closes
without co-operation.

\subsection{Summary}

\begin{table}[h]
  \begin{tabularx}{\textwidth}{ | X | l | l | l | l | l | l |}
  \hline
  Channel & Type & Optimal & Endless & Pulseless & Undelayed \\ \hline \hline
  Spilman-style & Uni & Yes & No & No & No \\ \hline
  CLTV-style & Uni & Yes & No & No & No \\ \hline
  Decker-Wattenhofer \gls{dmc} & Bi & No & Yes & No & No \\ \hline
  Poon-Dryja & Bi & No & Yes & Yes & Yes \\ \hline
  Shababi-Gugger-Lebrecht & Uni & No & Yes & Yes & Yes \\
  \hline
  \end{tabularx}
  \caption{Summary of different payment channels}
  \label{fig:summaryPaymentChannel}
\end{table}

This table summarizes the different properties of the proposed definitions of
central channel schemes. The last row refers to the next presented scheme.

% -----------------------------------------------------------------------------
\section{One-way channel (Shababi-Gugger-Lebrecht)}

Our one-way Payment Channel for Bitcoin is a simplified version of the Lightning
Network and \say{Yours Lightning Protocol} \cite{poon2016bitcoin,
YoursLightningProtocol}. The scheme is specially designed for a client
to provider scenario, where the provider has multiple clients through multiple
channels. The core design aims to be as cheap as possible for the provider while
being flexible for settlement. The white paper describing the core design more
in-depth is in the following appendices.

A part of this thesis was devoted to writing the white paper describing our
channel scheme while working on the scheme itself. During this work, we found a
possible attack, described in the white paper, which we fixed.

The next step has been to analyze how it is possible to optimize the channel
with threshold cryptography. As it is possible to see, every channel
construction depends on a funding transaction that locks funds in a 2-out-of-2
multi-signature script. This funding transaction is always on-chain, so if it's
possible to replace this script with a standard \gls{p2pkh} output the savings
should be attractive.

% -----------------------------------------------------------------------------
\section{Optimizing payment channels}

% Even if the channel is not completely trustless without \gls{segwit} we can compare the possible gain in non-\gls{segwit} mode.

Three transactions are compared with \gls{segwit}\footnote{ The transaction size
is calculated with nested-\gls{segwit} and not with native mode.} and without.
Optimization is expressed in percentage of size or virtual-size economized. The
Script Hash (SH) consumes a multi-signature script, and the Public Key Hash
(PKH) consumes a standard public key. Noted that size can vary few bytes with
\gls{segwit}.

% ** P2SH
% |               | segwit | segwit | non-segwit | non-segwit |
% |               |   size |  vsize |       size |      vsize |
% |---------------+--------+--------+------------+------------|
% | first refund  |    340 |    174 |        302 |        302 |
% | refund normal |    372 |    207 |        335 |        335 |
% | settlement    |    372 |    207 |        335 |        335 |
%
% ** PKH
% |               | segwit | segwit | non-segwit | non-segwit | native segwit | native segwit |
% |               |   size |  vsize |       size |      vsize |          size |         vsize |
% |---------------+--------+--------+------------+------------+---------------+---------------|
% | first refund  |    216 |    134 |        191 |        191 |           192 |           110 |
% | refund normal |    246 |    165 |        226 |        226 |           224 |           142 |
% | settlement    |    246 |    165 |        226 |        226 |           224 |           142 |

\newcolumntype{S}{>{\hsize=.5\hsize}C}
\begin{table}[h]
  \begin{tabularx}{\textwidth}{| X | S | S | S | S | S | S |}
  \cline{3-7}
  \multicolumn{2}{l|}{ } & \multicolumn{2}{c|}{Non-\gls{segwit}} & \multicolumn{3}{c|}{\gls{segwit}} \\ \cline{3-7}
  \multicolumn{2}{l|}{ } & R-Size & O & R-Size & V-Size & O \\ \hhline{--=====}
  \multirow{2}{*}{First Refund}  & SH   & 302  & \multirow{2}{*}{36.75\%} & 340 & 174  & \multirow{2}{*}{22.99\%} \\ \hhline{~--~--~}
                                 & PKH  & 191  &                          & 216 & 134  &                          \\ \hhline{-------}
  \multirow{2}{*}{Refund Normal} & SH   & 335  & \multirow{2}{*}{32.54\%} & 372 & 207  & \multirow{2}{*}{20.29\%} \\ \hhline{~--~--~}
                                 & PKH  & 226  &                          & 246 & 165  &                          \\ \hhline{-------}
  \multirow{2}{*}{Settlement}    & SH   & 335  & \multirow{2}{*}{32.54\%} & 372 & 207  & \multirow{2}{*}{20.29\%} \\ \hhline{~--~--~}
                                 & PKH  & 226  &                          & 246 & 165  &                          \\ \hhline{-------}
  \end{tabularx}
  \caption{Summary of transaction size optimization}
  \label{fig:summaryTransactionSizeOpti}
\end{table}

The average fee per byte in the last three months is around 292 Satoshis. This
optimization allows saving until 32,412 Satoshis for the first refund
transaction without \gls{segwit}, and 12,264 Satoshis for a refund or a
settlement transaction with \gls{segwit}. At the current price, these amounts
represent between USD \$1 and USD \$2.65\footnote{ Feb 2018}. If the channel is
used for micropayments such as a couple of cents each time, this optimization
makes the difference and lower the required threshold for rentability. The first
refund transaction being less expensive, this also makes the client commitment
easier.

Requirements need to be defined to be able to replace the multi-signature script
with a threshold scheme. Analyze the protocol and the signing process for a
multi-signature script allows to define these requirements. A multi-signature
script can be unlock with two different public keys and theire signature. These
signatures can be ordered in both directions, and signers order does not matter.
The protocol uses this observation. A transaction is usually held fully signed
only by one player. The threshold scheme must follow these requirements (i) 2
players need to co-operate to generate a valid signature, (ii) both must be able
to start the signing process, and (iii) only one player must be able to retrieve
the signature at the end of the process. If both need the signature a sharing is
always feasible, and the current protocol is not better in this case.

% \begin{table}[h]
%   \begin{tabularx}{\textwidth}{| X | S | S | S | S | S |}
%   \cline{2-6}
%   \multicolumn{1}{l|}{ } & \multicolumn{2}{c|}{Non-\gls{segwit}} & \multicolumn{3}{c|}{\gls{segwit}} \\ \cline{2-6}
%   \multicolumn{1}{l|}{ } & Raw Size & O & Raw Size & V-Size & O \\ \hhline{-=====}
%   Refund transaction & 100 & 0\% & 110 & 80 & 0\% \\
%   \hhline{------}
%   \end{tabularx}
%   \caption{Summary of transaction size optimization}
%   \label{fig:summaryTransactionSizeOpti}
% \end{table}
