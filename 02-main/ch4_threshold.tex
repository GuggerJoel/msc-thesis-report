\chapter{ECDSA asymmetric threshold scheme}
\label{chap:threshold}

% -- Your text goes here --

\minitoc

\newpage

% -----------------------------------------------------------------------------
\section{Reminder}

Before introducing the threshold scheme, a reminder of basic components used after in
the scheme is presented. The reminder is composed of \gls{ec} basic mathematics,
Paillier homomorphic encryption scheme, and digital signature---in particular
\gls{dsa} and \gls{ecdsa}.

\subsection{Elliptic curves}

Bitcoin use \gls{ec} cryptography for securing his transaction.
\gls{ecdsa}---based on the \gls{dsa} proposal by the \gls{nist}---over
the curve secp256k1---proposed by the \gls{secg}---is used. % TODO ref sec v2 paper

\subsubsection{Secp256k1 curve}
The curve secp256k1 is define over the finite field $\mathbb{F}_p$ of $2^{256}$ bits
with a Koblitz curve $y^2 = x^3 + ax + b$ where $a = 0$ and $b = 7$.
\begin{equation*}
\begin{split}
  y^2 &= x^3 + 7\\
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
  p &= &\text{\scriptsize FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F}\\
  G &= &\text{\scriptsize (79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798,}\\
    &  &\text{\scriptsize  483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8)}\\
  n &= &\text{\scriptsize FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141}
\end{split}
\end{equation*}

The curve order $n$ define the number of element (points) generated by the generator
$G$ on the curve. An exponentiation of the generator $g^a \mod p$ become a point multiplication
with the generator $a \cdot G$.

\subsubsection{Points addition}
With two distinct point $P$ and $Q$ on the curve $\mathcal{E}$, geometrically the resulting point of the
addition is the inverse point, $(x, -y)$ of the intersection point with a straight
line between $P$ and $Q$. An infinity point $\mathcal{O}$ represent the identity element in the group.
Algebraically the resulting point is obtained with:
\begin{equation}
\begin{split}
  P + Q &= Q + P = P + Q + \mathcal{O} = R \\
  (x_p, y_p) + (x_q, y_q) &= (x_r, y_r) \\
  x_r &\equiv \lambda^2 - x_p - x_q \pmod p \\
  y_r &\equiv \lambda(x_p - x_r) - y_p \pmod p  \\
  \lambda &= \cfrac{y_q - y_p}{x_q - x_p} \\
          &\equiv (y_q - y_p)(x_q - x_p)^{-1} \pmod p
\end{split}
\end{equation}

\subsubsection{Point doubling}
For $P$ and $Q$ equal, the formula is similar, the tangent to the curve $\mathcal{E}$ at
point $P$ determine $R$.
\begin{equation}
\begin{split}
  P + P &= 2P = R \\
  (x_p, y_p) + (x_p, y_p) &= (x_r, y_r) \\
  x_r &\equiv \lambda^2 - 2x_p \pmod p \\
  y_r &\equiv \lambda(x_p - x_r) - y_p \pmod p  \\
  \lambda &= \cfrac{3x_p^2 + a}{2y_p} \\
          &\equiv (3x_p^2 + a)(2y_p)^{-1} \pmod p
\end{split}
\end{equation}

\subsubsection{Point multiplication}
A point $P$ can be multiply by a scalar $d$. The straightforward way of computing
a point multiplication is through repeated addition where $dP = P_1 + P_2 + \dots + P_d$.

% However, this is a fully
% exponential approach to computing the multiplication.
% The simplest method is the double-and-add method. To compute
% $dP = P_1 + P_2 + \dots + P_d$, start with the
% binary representation for $d : d = d_0 + 2d_1 + 2^2d_2 + \dots + 2^md_m$,
% where
% $[ d_0 \dots d_m] \in {0,1}$, $N = P, Q = \mathcal{O} \and \forall d_x : \text{if } d_x = 1 Q = \text{add}(Q, P), N = \text{double}(N)$.


\begin{lemma}[Elliptic Curve Discrete Logarithm Problem]
  Given a multiple $Q$ of $P$ where $Q = nP$ it is infeasible to find $n$ if $n$ is
  large.
\end{lemma}

\begin{lemma}[Point Order]
  A point $P$ has order $2$ if $P + P = \mathcal{O}$, and therefore $P = -P$.
  A point $Q$ has order $3$ if $Q+Q+Q=\mathcal{O}$, and therefore $Q + Q = -Q$.
\end{lemma}


\subsection{Paillier cryptosystem}

\begin{quote}
  The Paillier cryptosystem, invented by and named after Pascal Paillier in 1999,
  is a probabilistic asymmetric algorithm for public key cryptography. The problem
  of computing $n$-th residue classes is believed to be computationally difficult.
  The decisional composite residuosity assumption is the intractability hypothesis
  upon which this cryptosystem is based.
\end{quote}

\subsubsection{Encryption}

With a public key $(n, g)$ and a message $m < n$, select a random $r < n$ and
compute the ciphertext $c = g^m \cdot r^n \mod n^2$ to encrypt the plaintext.

\subsubsection{Decryption}

With a private key $(n, g, \lambda, \mu)$ and a ciphertext $c \in \mathbb{Z}_{n^2}^*$
compute the plaintext as $m = L(c^{\lambda} \mod n^2) \cdot \mu \mod n$
where $L(x) = \frac{x-1}{n}$.

\subsection{Signature schemes}
\subsubsection{Digital Signature Algorithm}

\begin{quote}
  The Digital Signature Algorithm (DSA) is a Federal Information Processing Standard
  for digital signatures. In August 1991 the National Institute of Standards and
  Technology (NIST) proposed DSA for use in their Digital Signature Standard (DSS)
  and adopted it as FIPS 186 in 1993.
\end{quote}

\paragraph{Signing}

With public parameters $(p, q, g)$, \texttt{hash} the hashing function,
$m$ the message, and $x \in \mathbb{Z}_q$ the private key.

\begin{itemize}
  \item Generate a random $k \in \mathbb{Z}_q$
  \item Calculate $r \equiv (g^k \pmod p) \pmod q : r \neq 0$
  \item Calculate $s \equiv k^{-1}(\texttt{hash}(m) + xr) \pmod q : s \neq 0$
  \item The signature is $(r, s)$
\end{itemize}

\paragraph{Verifying}

With public parameters $(p, q, g)$, \texttt{hash} the hashing function,
$m$ the message, $(r, s)$ the signature, and $y = g^x \mod p$ the public key.

\begin{itemize}
  \item Reject the signature if $r, s \notin \mathbb{Z}_q$
  \item Calculate $w \equiv s^{-1} \pmod q$
  \item Calculate $u_1 \equiv \texttt{hash}(m) \cdot w \pmod q$
  \item Calculate $u_2 \equiv rw \pmod q$
  \item Calculate $v \equiv (g^{u_1}y^{u_2} \pmod p) \pmod q$
  \item The signature is valide iff $v = r$
\end{itemize}

\subsubsection{Elliptic Curve Digital Signature Algorithm}

\gls{ecdsa} is a variant of \gls{dsa} which uses elliptic curve cryptography and
require a different set of parameters and smaller keys.

\paragraph{Signing}

With public parameters $(\mathcal{E}, G, n)$, \texttt{hash} the hashing function,
$m$ the message, and $x \in \mathbb{Z}_n$ the private key.

\begin{itemize}
  \item Generate a random $k \in \mathbb{Z}_n$
  \item Calculate $(x_1, y_1) = k \cdot G$
  \item Calculate $r \equiv x_1 \pmod n : r \neq 0$
  \item Calculate $s \equiv k^{-1}(\texttt{hash}(m) + xr) \pmod n : s \neq 0$
  \item The signature is $(r, s)$
\end{itemize}

\paragraph{Verifying}

With public parameters $(\mathcal{E}, G, n)$, \texttt{hash} the hashing function,
$m$ the message, $(r, s)$ the signature, and $Q = x \cdot G$ the public key.

\begin{itemize}
  \item Reject the signature if $r, s \notin \mathbb{Z}_n$
  \item Calculate $w \equiv s^{-1} \pmod n$
  \item Calculate $u_1 \equiv \texttt{hash}(m) \cdot w \pmod n$
  \item Calculate $u_2 \equiv rw \pmod n$
  \item Calculate the curve point $(x_1, y_1) = u_1 \cdot G + u_2 \cdot Q$ if
  $(x_1, y_1) = \mathcal{O}$ then the signature is invalid
  \item The signature is valide iff $r \equiv x_1 \pmod n$
\end{itemize}

\subsubsection{Schemes' analysis}

In $(r, s)$ the part $s$ remain the same in each signature scheme, the only difference
for $s$ is the modulus applied. In \gls{dsa} the modulus $q$, i.e. the order of
the generator $g$ modulo $p$, is took while in \gls{ecdsa} the modulus $n$, i.e. the
order of the generator $G$ on the curve $\mathcal{E}$, is took.

The biggest adaptation is on how to calculate the part $r$ from the private random $k$.
In \gls{dsa} the generator $g$ is used with, at first, modulo $p$ and then
modulo $q$ while in \gls{ecdsa} the curve is used. A point is calculated and the
coordinate $x_1$ is used modulo $n$.

\begin{postulate}
  This statement $a \equiv g^b \pmod p$ is equivalent in term of security to $a = b \cdot G$
  and $a \equiv (g^b \pmod p) \pmod q$ is equivalent to $a \equiv x \pmod n : (x, y) = b \cdot G$.
  \label{post:adaptEcdsa}
\end{postulate}

The previous postulate is used to adapt zero-knowledge proofs from \gls{dsa} to
\gls{ecdsa} hereafter. This postulate has not been further researched by lack
of time.


% -----------------------------------------------------------------------------
\section{Threshold scheme}

The \say{Two-party generation of DSA signatures} scheme presented by MacKenzie
and Reiter, as mentionned before, is an asymmetric scheme, i.e. at the end of the
protocol only the initiator can retreive the full signature. The scheme proposed
is a cryptographic (1,2)-threshold, i.e. one player can be corrupted on the two
players and the scheme remain safe. It is worth noting that this is qualified as
an optimal $(t, n)$-threshold scheme, i.e. $t = n - 1$, because if only one
honest player remain the safety is guarantee.

As also mentionned before, the scheme correspond to the same requirement of a
Bitcoin 2-out-of-2 multi-signatures script. This means that it is possible to
use it to improve the payment channels. However, it is necessary to adapt the
scheme and particulary the zero-knowledge proofs construction to \gls{ecdsa}.
The approach is explained in the following.

% Recap the threat model ??!?!

The presented scheme use a multiplicative shared secret and a multiplicative shared
private random value. The secret $x$ is shared between Alice and Bob, so that Alice
holds the secret value $x_1 \in \mathbb{Z}_{q}$ and Bob $x_2 \in \mathbb{Z}_{q}$
such that $x \equiv x_1x_2 \pmod q$. Along with the public key $y$,
$y_1 \equiv g^{x_1} \pmod p$ and $y_2 \equiv g^{x_2} \pmod p$ are public.
Alice holds a private key, hereinafter mentionned as $sk$, corresponding to a
public encryption key $pk$. Alice also knows a public encryption key $pk'$ for
which she does not know the private key $sk'$. Here the Paillier homomorphic
cryptosystem is used as the encryption scheme, but it is worth noting that others
homomorphic encryption systems can be use to implement the scheme. Alice and Bob
know a set of parameters used for both zero-knowledge proofs.

Hereinafter, the initialisation is not taken into account. The choice was made to
decrease the amount of work and because the implementation is not part of the
cryptographic \texttt{C} library. This part can be a further research for an other
thesis.

\subsection{Adapting the scheme}

Except for the zero-knowledge proofs, the adaptation is trivial and require just
the same adaptation from \gls{dsa} signature scheme and \gls{ecdsa} signature
scheme, i.e. compute the $r$ value with the curve. The following figure describe
the adapted scheme. Messages stay the same and are not repeated.
The postulate~\ref{post:adaptEcdsa} is used to perform the adaptation.

The secret remain shared multiplicatively so that so that Alice holds the secret
value $x_1 \in \mathbb{Z}_{n}$ and Bob $x_2 \in \mathbb{Z}_{n}$ such that
$x \equiv x_1x_2 \pmod n$. Alice holds her public key $Q_1 = x_1 \cdot G$ and Bob
$Q_2 = x_2 \cdot G$ such that $Q = x_1 \cdot Q_2$ for Alice or $Q = x_2 \cdot Q_1$
for Bob. The notation $\cdot$ is used to denote the point multiplication over \gls{ec}.

All the random values $k$ are choose in $\mathbb{Z}_{n}$ instead of $\mathbb{Z}_{q}$,
also in the case of deterministic signature. All the computation modulo $q$ is replaced
by modulo $n$, as shown in the foregoing digital signature recap.
Values $R_2$ and $R$ become points. Verifications of values $R_2$ and $R$ become
point verifications on the curve and $r'$ is calculated by Alice and Bob as shown
in the foregoing remainder. The value $cq$ added to the homomorphic encrypted signature
is transformed into $cn$ to hide values $z_2$ and $x_2z_2$.

A error of notation is noticed in the original paper, on the
second line Alice compute $z_1 \equiv (k_1)^{-1} \pmod n$ and the original paper
use the random value selection $\xleftarrow[]{R}$ instead of a standard assignation $\leftarrow$,
this error has been corrected in the following version of the protocol.

\newpage

\begin{figure}[H]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      {\renewcommand{\arraystretch}{1.2}%
      \begin{tabular}{ | l l | }
        \hline
        \multicolumn{1}{|c}{alice}  & \multicolumn{1}{c|}{bob} \\
        $k_1 \xleftarrow[]{R} \mathbb{Z}_{n}$ & \\
        $z_1 \leftarrow (k_1)^{-1} \mod n$ & \\
        $\alpha \leftarrow E_{pk}(z_1)$ & \\
        $\zeta \leftarrow E_{pk}(x_1z_1 \mod n)$ & \\[2ex]
          & abort if($\alpha \notin C_{pk} \lor \zeta \notin C_{pk}$) \\
          & $k_2 \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
          & $\mathcal{R}_2 \leftarrow k_2 \cdot \mathcal{G}$ \\[2ex]
        abort if($\mathcal{R}_2 \notin \mathcal{E}$) & \\
        $\mathcal{R} \leftarrow k_1 \cdot \mathcal{R}_2$ & \\
        \multicolumn{2}{|l|}{
        $\Pi \leftarrow \texttt{zkp} \begin{bmatrix}\begin{array}{lr}
                                      \exists \eta_1, \eta_2 : & \eta_1, \eta_2 \in [-n^3, n^3] \\
                                      \land & \eta_1 \cdot \mathcal{R} = \mathcal{R}_2 \\
                                      \land & (\eta_2/\eta_1) \cdot \mathcal{G} = \mathcal{Q}_1 \\
                                      \land & D_{sk}(\alpha) \equiv_n \eta_1 \\
                                      \land & D_{sk}(\zeta) \equiv_n \eta_2
                                     \end{array}\end{bmatrix}$ } \\ & \\
          & abort if($\mathcal{R} \notin \mathcal{E}$) \\
          & abort if(\texttt{Verifier}$(\Pi) = 0$) \\
          & $m' \leftarrow \texttt{h}(m)$ \\
          & $r' \leftarrow x \mod n : (x,y) = \mathcal{R}$ \\
          & $z_2 \leftarrow (k_2)^{-1} \mod n$ \\
          & $c \xleftarrow[]{R} \mathbb{Z}_{n^5}$ \\
          & $\begin{aligned}[t]
              \mu \leftarrow & (\alpha \times_{pk} m'z_2) +_{pk} \\
                             & (\zeta \times_{pk} r'x_2z_2) +_{pk} E_{pk}(cn)
            \end{aligned}$ \\
          & $\mu' \leftarrow E_{pk'}(z_2)$ \\
          & {$\Pi' \leftarrow \texttt{zkp} \begin{bmatrix}\begin{array}{lr}
                                            \exists \eta_1, \eta_2, \eta_3 : & \eta_1, \eta_2 \in [-n^3, n^3] \\
                                            \land & \eta_3 \in [-n^5, n^5] \\
                                            \land & \eta_1 \cdot \mathcal{R}_2 = \mathcal{G} \\
                                            \land & (\eta_2/\eta_1) \cdot \mathcal{G} = \mathcal{Q}_2 \\
                                            \land & D_{sk'}(\mu') \equiv_n \eta_1 \\
                                            \multicolumn{2}{l}{
                                              \begin{aligned}[t]
                                                  \land \quad D_{sk}(\mu) \equiv_n & D_{sk}((\alpha \times_{pk} m'\eta_1) +_{pk} \\
                                                                                   & (\zeta \times_{pk} r'\eta_2) +_{pk} E_{pk}(n\eta_3))
                                                \end{aligned}
                                            }
                                           \end{array}\end{bmatrix}$} \\ & \\
        abort if($\mu \notin C_{pk} \lor \mu' \notin C_{pk'}$) & \\
        abort if(\texttt{Verifier}$(\Pi') = 0$) & \\
        $s \leftarrow D_{sk}(\mu) \mod n$ & \\
        $r \leftarrow x \mod n : (x,y) = \mathcal{R}$ & \\
        publish <$r$, $s$> & \\
        \hline
      \end{tabular}}
      \end{footnotesize}
    \end{table}

  \caption{Adapted protocol for ECDSA}
  \label{fig:adaptationSchemeECDSA}
\end{figure}

\subsection{Adapting zero-knowledge proofs}

Initialy the proofs have been designed for the DSA architecture, so the values
tested in the proofs are values in $\mathbb{Z}_{q}$. These values are used to create
a challenge $e$ with two hash function (a different one per proof.) For ECDSA some
of these values become points and some equations need to be adapted. Points are
serialized in the long form, 65 bytes starting with \texttt{0x04} and two 32 bytes
number for the coordinates $(x, y)$.
As mentionned is the original paper, the variables names are not consistent with
the first part of the paper. Hereinafter the variable names follow the same notation
as the original paper and are therefore no longer consistent with the previous
pages.

\subsubsection{Zero-knowledge proof $\Pi$}

The first zero-knowledge proof $\Pi$ is created by Alice to prove to Bob that she
act correctly and have encrypted coherent data with Paillier encryption, proving the
ownership and the validity of the two encrypted values in relation to the public address
$Q_1$ with $(x_1z_1 / z_1) \cdot G = Q_1$. The proof states that the encrypted value
$\alpha$ is related to $R$ and $R_2$ such that
$(k_1)^{-1} \cdot R = ((k_1)^{-1}k_1k_2) \cdot G = k_2 \cdot G = R_2$.

\begin{figure}[h]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
        \[
        \Pi \leftarrow \texttt{zkp} \begin{bmatrix}\begin{array}{lr}
                                      \exists x_1, x_2 : & x_1, x_2 \in [-n^3, n^3] \\
                                      \land & x_1 \cdot \mathcal{C} = \mathcal{W}_1 \\
                                      \land & (x_2/x_1) \cdot \mathcal{D} = \mathcal{W}_2 \\
                                      \land & D_{sk}(m_1) \equiv_n x_1 \\
                                      \land & D_{sk}(m_2) \equiv_n x_2
                                     \end{array}\end{bmatrix}
        \]
      \end{footnotesize}
    \end{table}

  \caption{The proof $\Pi$}
  \label{fig:theProofPi}
\end{figure}

\begin{table}[h]
  \begin{tabular}{p{4cm} l}
    $x_1 = z_1$ & $\mathcal{C} = \mathcal{R}$ \\
    $x_2 = x_1z_1 \mod n$ & $\mathcal{D} = \mathcal{G}$ \\
    $m_1 = \alpha$ & $\mathcal{W}_1 = \mathcal{R}_2$ \\
    $m_2 = \zeta$ & $\mathcal{W}_2 = \mathcal{Q}_1$
  \end{tabular}
  \caption{Mapping between the protocol's variable names and the ZKP $\Pi$}
  \label{fig:mappingOfVarNamesPi}
\end{table}

\begin{figure}[h]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      \begin{tabular}{ | p{6cm} p{6cm} | }
        \hline
        \multicolumn{2}{ | c | }{$\langle z_1, z_2, \mathcal{Y}, e, s_1, s_2, s_3, t_1, t_2, t_3, t_4 \rangle \leftarrow \Pi$} \\
          & \\
        $\text{Verify } s_1, t_1 \in \mathbb{Z}_{n^3}$ & $\mathcal{V}_1 \leftarrow (t_1 + t_2) \cdot \mathcal{D} + (-e) \cdot \mathcal{Y}$ \\
        $\mathcal{U}_1 \leftarrow s_1 \cdot \mathcal{C} + (-e) \cdot \mathcal{W}_1$ & $\mathcal{V}_2 \leftarrow s_1 \cdot \mathcal{W}_2 + t_2 \cdot \mathcal{D} + (-e) \cdot \mathcal{Y}$ \\
        $u_2 \leftarrow g^{s_1}(s_2)^N(m_1)^{-e} \mod N^2$ & $v_3 \leftarrow g^{t_1} (t_3)^N (m_2)^{-e} \mod N^2$ \\
        $u_3 \leftarrow (h_1)^{s_1} (h_2)^{s_3} (z_1)^{-e} \mod \tilde{N}$ & $v_4 \leftarrow (h_1)^{t_1} (h_2)^{t_4} (z_2)^{-e} \mod \tilde{N}$ \\
         & \\
        \multicolumn{2}{|c|}{$\text{Verify } e = \texttt{hash}(\mathcal{C}, \mathcal{W}_1, \mathcal{D}, \mathcal{W}_2, m_1, m_2, z_1, \mathcal{U}_1, u_2, u_3, z_2, \mathcal{Y}, \mathcal{V}_1, \mathcal{V}_2, v_3, v_4)$} \\
        \hline
      \end{tabular}
      \end{footnotesize}
    \end{table}

  \caption{Adaptation of $\Pi$'s verification in ECDSA}
  \label{fig:adaptationOfPiVerification}
\end{figure}

\begin{figure}[h]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      \begin{tabular}{ | p{5cm} p{5cm} | }
        \hline
        $\alpha \xleftarrow[]{R} \mathbb{Z}_{n^3}$ & $\delta \xleftarrow[]{R} \mathbb{Z}_{n^3}$ \\
        $\beta \xleftarrow[]{R} \mathbb{Z}_{N}^{*}$ & $\mu \xleftarrow[]{R} \mathbb{Z}_{N}^{*}$ \\
        $\gamma \xleftarrow[]{R} \mathbb{Z}_{n^{3}\tilde{N}}$ & $\nu \xleftarrow[]{R} \mathbb{Z}_{n^{3}\tilde{N}}$ \\
        $\rho_1 \xleftarrow[]{R} \mathbb{Z}_{n\tilde{N}}$ & $\rho_2 \xleftarrow[]{R} \mathbb{Z}_{n\tilde{N}}$ \\
         & $\rho_3 \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
         & $\epsilon \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
         & \\
        $z_1 \leftarrow (h_1)^{x_1}(h_2)^{\rho_1} \mod \tilde{N}$ & $z_2 \leftarrow (h_1)^{x_2}(h_2)^{\rho_2} \mod \tilde{N}$ \\
        $\mathcal{U}_1 \leftarrow \alpha \cdot \mathcal{C}$ & $\mathcal{Y} \leftarrow (x_2 + \rho_3) \cdot \mathcal{D}$ \\
        $u_2 \leftarrow g^{\alpha} \beta^{N} \mod N^2$ & $\mathcal{V}_1 \leftarrow (\delta + \epsilon) \cdot \mathcal{D}$ \\
        $u_3 \leftarrow (h_1)^{\alpha} (h_2)^{\gamma} \mod \tilde{N}$ & $\mathcal{V}_2 \leftarrow \alpha \cdot \mathcal{W}_2 + \epsilon \cdot \mathcal{D}$ \\
         & $v_3 \leftarrow g^{\delta} \mu^{N} \mod N^2$ \\
         & $v_4 \leftarrow (h_1)^{\delta} (h_2)^{\nu} \mod \tilde{N}$ \\
         & \\
        \multicolumn{2}{|l|}{$e \leftarrow \texttt{hash}(\mathcal{C}, \mathcal{W}_1, \mathcal{D}, \mathcal{W}_2, m_1, m_2, z_1, \mathcal{U}_1, u_2, u_3, z_2, \mathcal{Y}, \mathcal{V}_1, \mathcal{V}_2, v_3, v_4)$} \\
         & \\
        $s_1 \leftarrow ex_1 + \alpha$ & $t_1 \leftarrow ex_2 + \delta$ \\
        $s_2 \leftarrow (r_1)^e \beta \mod N$ & $t_2 \leftarrow e \rho_3 + \epsilon \mod n$ \\
        $s_3 \leftarrow e \rho_1 + \gamma$ & $t_3 \leftarrow (r_2)^e \mu \mod N^2$ \\
         & $t_4 \leftarrow e \rho_2 + \nu$ \\
         & \\
        \multicolumn{2}{ | c | }{$\Pi \leftarrow \langle z_1, z_2, \mathcal{Y}, e, s_1, s_2, s_3, t_1, t_2, t_3, t_4 \rangle$} \\
        \hline
      \end{tabular}
      \end{footnotesize}
    \end{table}

  \caption{Adaptation of $\Pi$'s construction in ECDSA}
  \label{fig:adaptationOfPi}
\end{figure}

\subsubsection{Zero-knowledge proof $\Pi'$}

The second zero-knowledge proof is created by Bob to prove to Alice that he acted honestly
according to the protocol. The proof states that the point $\mathcal{R}_2$ is generated
accordingly to the value $z_2$ and then to the value $k_2$, the public key $\mathcal{Q}_2$
is related to the values $z_2$ and $x_2z_2$, and the encrypted values $\mu$ and $\mu'$
are correctly composed.

\begin{table}[h]
  \begin{tabular}{p{4cm} l}
    $x_1 = z_2$ & $\mathcal{C} = \mathcal{R}_2$ \\
    $x_2 = x_2z_2 \mod n$ & $\mathcal{D} = \mathcal{G}$ \\
    $x_3 = c \mod n$ & $\mathcal{W}_1 = \mathcal{G}$ \\
    $m_1 = \mu'$ & $\mathcal{W}_2 = \mathcal{Q}_2$ \\
    $m_2 = \mu$ & $m_3 = \alpha$ \\
    $m_4 = \zeta$ &
  \end{tabular}
  \caption{Mapping between the protocol's variable names and the ZKP $\Pi'$}
  \label{fig:mappingOfVarNamesPi2}
\end{table}

\begin{figure}[h]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
        \[
        \Pi' \leftarrow \texttt{zkp} \begin{bmatrix}\begin{array}{lr}
                                          \exists x_1, x_2, x_3 : & x_1, x_2 \in [-n^3, n^3] \\
                                          \land & x_3 \in [-n^5, n^5] \\
                                          \land & x_1 \cdot \mathcal{C} = \mathcal{W}_1 \\
                                          \land & (x_2/x_1) \cdot \mathcal{D} = \mathcal{W}_2 \\
                                          \land & D_{sk'}(m_1) \equiv_n x_1 \\
                                          \multicolumn{2}{l}{
                                            \begin{aligned}[t]
                                                \land \quad D_{sk}(m_2) \equiv_n & D_{sk}((m_3 \times_{pk} m'x_1) +_{pk} \\
                                                                                 & (m_4 \times_{pk} r'x_2) +_{pk} E_{pk}(nx_3))
                                              \end{aligned}
                                          }
                                         \end{array}\end{bmatrix}
        \]
      \end{footnotesize}
    \end{table}

  \caption{The proof $\Pi'$}
  \label{fig:theProofPi2}
\end{figure}

\paragraph{Correcting the verification of $\Pi'$}
If $x_1 = z_2$, $x_2 = x_2 z_2$, $x_3 = c$, and $m_2 = \mu$ such that
$\mu = (\alpha)^{m' x_1} (\zeta)^{r' x_2} g^{nx_3} (r_2)^{N}$, then the
equation $v_3$ in the validation proccess does not correspond to construction
of $v_3$ in the original paper.
The result in the verification proccess $\Pi'$ need to match
$v_3 \leftarrow (m_3)^{\alpha} (m_4)^{\delta} g^{n \sigma} \mu^{N} \mod N^2$.
The original equation proposed
$v_3 \leftarrow (m_3)^{s_1} (m_4)^{t_1} g^{nt_5} (t_3)^{N} (m_2)^{-e} \mod N^2$
does not include $m'$ and $r'$ present in $\mu$, so $m_2$ cannot be used correctly
as showed next.

\begin{equation}
\begin{split}
   v_3 &\equiv (m_3)^{s_1} (m_4)^{t_1} g^{nt_5} (t_3)^{N} (m_2)^{-e} \pmod{N^2} \\
       &\equiv (m_3)^{ex_1 + \alpha} (m_4)^{ex_2 + \beta} g^{n(ex_3 + \sigma)}
       \big((r_2)^e \mu\big)^{N}
       \big((m_3)^{m' x_1} (m_4)^{r' x_2} g^{nx_3} (r_2)^{N}\big)^{-e} \\
       &\equiv (m_3)^{ex_1 + \alpha} (m_4)^{ex_2 + \beta} g^{n(ex_3 + \sigma)}
       (r_2)^{eN} \mu^{N}
       (m_3)^{-e m' x_1} (m_4)^{-e r' x_2} g^{-e nx_3} (r_2)^{-eN} \\
       &\equiv (m_3)^{ex_1 + \alpha - e m' x_1} (m_4)^{ex_2 + \beta - e r' x_2}
       g^{enx_3 + n\sigma - enx_3} (r_2)^{eN - eN} \mu^{N}  \\
       &\equiv (m_3)^{ex_1 + \alpha - e m' x_1} (m_4)^{ex_2 + \beta - e r' x_2}
       g^{n\sigma} \mu^{N}  \\
\end{split}
\end{equation}

The equation $v_3$ needs to be adapted to include $x_4 = m'$ and $x_5 = r'$ ($m'$
and $r'$ cannot be include directly in $x_1$ and $x_2$ without breaking
equations $u_1, u_2, u_3, v_2$.) Two new parameters $s_4 \leftarrow ex_1 x_4 + \alpha$ and
$t_7 \leftarrow ex_2 x_5 + \delta$ are added into the proof to correct
the equation.

\begin{equation}
\begin{split}
   v_3 &\equiv (m_3)^{s_4} (m_4)^{t_7} g^{nt_5} (t_3)^{N} (m_2)^{-e} \pmod{N^2} \\
       &\equiv (m_3)^{ex_1x_4 + \alpha} (m_4)^{ex_2x_5 + \beta} g^{n(ex_3 + \sigma)}
       \big((r_2)^e \mu\big)^{N}
       \big((m_3)^{x_1x_4} (m_4)^{x_2x_5} g^{nx_3} (r_2)^{N}\big)^{-e} \\
       &\equiv (m_3)^{ex_1x_4 + \alpha} (m_4)^{ex_2x_5 + \beta} g^{n(ex_3 + \sigma)}
       (r_2)^{eN} \mu^{N}
       (m_3)^{-e x_1x_4} (m_4)^{-e x_2x_5} g^{-e nx_3} (r_2)^{-eN} \\
       &\equiv (m_3)^{ex_1x_4 + \alpha - e x_1x_4} (m_4)^{ex_2x_5 + \beta - e x_2x_5}
       g^{enx_3 + n\sigma - enx_3} (r_2)^{eN - eN} \mu^{N}  \\
       &\equiv (m_3)^{\alpha} (m_4)^{\beta} g^{n\sigma} \mu^{N} \\
\end{split}
\end{equation}


\begin{figure}[ht]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      \begin{tabular}{ | p{5.5cm} p{6cm} | }
        \hline
        $\alpha \xleftarrow[]{R} \mathbb{Z}_{n^3}$ & $\delta \xleftarrow[]{R} \mathbb{Z}_{n^3}$ \\
        $\beta \xleftarrow[]{R} \mathbb{Z}_{N'}^{*}$ & $\mu \xleftarrow[]{R} \mathbb{Z}_{N}^{*}$ \\
        $\gamma \xleftarrow[]{R} \mathbb{Z}_{n^{3}\tilde{N}}$ & $\nu \xleftarrow[]{R} \mathbb{Z}_{n^{3}\tilde{N}}$ \\
        $\rho_1 \xleftarrow[]{R} \mathbb{Z}_{n\tilde{N}}$ & $\rho_2 \xleftarrow[]{R} \mathbb{Z}_{n\tilde{N}}$ \\
         & $\rho_3 \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
         & $\rho_4 \xleftarrow[]{R} \mathbb{Z}_{n^5\tilde{N}}$ \\
         & $\epsilon \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
         & $\sigma \xleftarrow[]{R} \mathbb{Z}_{n^7}$ \\
         & $\tau \xleftarrow[]{R} \mathbb{Z}_{n^7\tilde{N}}$ \\
         & \\
        $z_1 \leftarrow (h_1)^{x_1}(h_2)^{\rho_1} \mod \tilde{N}$ & $z_2 \leftarrow (h_1)^{x_2}(h_2)^{\rho_2} \mod \tilde{N}$ \\
        $\mathcal{U}_1 \leftarrow \alpha \cdot \mathcal{C}$ & $\mathcal{Y} \leftarrow (x_2 + \rho_3) \cdot \mathcal{D}$ \\
        $u_2 \leftarrow (g')^{\alpha} \beta^{N'} \mod (N')^2$ & $\mathcal{V}_1 \leftarrow (\delta + \epsilon) \cdot \mathcal{D}$ \\
        $u_3 \leftarrow (h_1)^{\alpha} (h_2)^{\gamma} \mod \tilde{N}$ & $\mathcal{V}_2 \leftarrow \alpha \cdot \mathcal{W}_2 + \epsilon \cdot \mathcal{D}$ \\
         & $v_3 \leftarrow (m_3)^{\alpha} (m_4)^{\delta} g^{n \sigma} \mu^{N} \mod N^2$ \\
         & $v_4 \leftarrow (h_1)^{\delta} (h_2)^{\nu} \mod \tilde{N}$ \\
         & $z_3 \leftarrow (h_1)^{x_3} (h_2)^{\rho_4} \mod \tilde{N}$ \\
         & $v_5 \leftarrow (h_1)^{\sigma} (h_2)^{\tau} \mod \tilde{N}$ \\
         & \\
        \multicolumn{2}{ | l | }{$e \leftarrow \texttt{hash'}(\mathcal{C}, \mathcal{W}_1, \mathcal{D}, \mathcal{W}_2, m_1, m_2, z_1, \mathcal{U}_1, u_2, u_3, z_2, z_3, \mathcal{Y}, \mathcal{V}_1, \mathcal{V}_2, v_3, v_4, v_5)$} \\
         & \\
        $s_1 \leftarrow ex_1 + \alpha$ & $t_1 \leftarrow ex_2 + \delta$ \\
        $s_2 \leftarrow (r_1)^e \beta \mod N'$ & $t_2 \leftarrow e \rho_3 + \epsilon \mod n$ \\
        $s_3 \leftarrow e \rho_1 + \gamma$ & $t_3 \leftarrow (r_2)^e \mu \mod N$ \\
        $s_4 \leftarrow ex_1 x_4 + \alpha$ & $t_4 \leftarrow e \rho_2 + \nu$ \\
         & $t_5 \leftarrow e x_3 + \sigma$ \\
         & $t_6 \leftarrow e \rho_4 + \tau$ \\
         & $t_7 \leftarrow ex_2 x_5 + \delta$ \\
         & \\
        \multicolumn{2}{ | c | }{$\Pi' \leftarrow \langle z_1, z_2, z_3, \mathcal{Y}, e, s_1, s_2, s_3, s_4, t_1, t_2, t_3, t_4, t_5, t_6, t_7 \rangle$} \\
        \hline
      \end{tabular}
      \end{footnotesize}
    \end{table}

  \caption{Adaptation of $\Pi'$'s construction in ECDSA}
  \label{fig:adaptationOfPi2}
\end{figure}


\begin{figure}[ht]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      \begin{tabular}{ | p{6cm} p{6cm} | }
        \hline
        \multicolumn{2}{ | c | }{$\langle z_1, z_2, z_3, \mathcal{Y}, e, s_1, s_2, s_3, s_4, t_1, t_2, t_3, t_4, t_5, t_6, t_7 \rangle \leftarrow \Pi'$} \\
          & \\
        $\text{Verify } s_1, t_1 \in \mathbb{Z}_{n^3}$ & $\mathcal{V}_1 \leftarrow (t_1 + t_2) \cdot \mathcal{D} + (-e) \cdot \mathcal{Y}$ \\
        $\text{Verify } t_5 \in \mathbb{Z}_{n^7}$ & $\mathcal{V}_2 \leftarrow s_1 \cdot \mathcal{W}_2 + t_2 \cdot \mathcal{D} + (-e) \cdot \mathcal{Y}$ \\

        $\mathcal{U}_1 \leftarrow s_1 \cdot \mathcal{C} + (-e) \cdot \mathcal{W}_1$ &
        $\begin{aligned}[t]
            v_3 \leftarrow & (m_3)^{s_4} (m_4)^{t_7} g^{nt_5} (t_3)^{N} (m_2)^{-e} \\
                           &\mod N^2
          \end{aligned}$ \\
        $u_2 \leftarrow (g')^{s_1} (s_2)^{N'} (m_1)^{-e} \mod (N')^2$ & $v_4 \leftarrow (h_1)^{t_1} (h_2)^{t_4} (z_2)^{-e} \mod \tilde{N}$ \\
        $u_3 \leftarrow (h_1)^{s_1} (h_2)^{s_3} (z_1)^{-e} \mod \tilde{N}$ &  $v_5 \leftarrow (h_1)^{t_5} (h_2)^{t_6} (z_3)^{-e} \mod \tilde{N}$\\
         & \\
        \multicolumn{2}{ | c | }{$\text{Verify } e = \texttt{hash'}(\mathcal{C}, \mathcal{W}_1, \mathcal{D}, \mathcal{W}_2, m_1, m_2, z_1, \mathcal{U}_1, u_2, u_3, z_2, z_3, \mathcal{Y}, \mathcal{V}_1, \mathcal{V}_2, v_3, v_4, v_5)$} \\
        \hline
      \end{tabular}
      \end{footnotesize}
    \end{table}

  \caption{Adaptation of $\Pi'$ verification to ECDSA}
  \label{fig:adaptationOfPi2Verification}
\end{figure}

\vfill
\newpage


% -----------------------------------------------------------------------------
\section{Threshold Hierarchical Determinitic Wallets}

Hierarchical deterministic wallets are sophisticated wallets in wich fresh keys
can be generated from a previous key. Adapting hierarchical deterministic wallets
with a threshold scheme can be achieve by sharing the private key additively:

\begin{equation*}
\begin{split}
  pk_i     &= sk_i \cdot G \\
  sk_{mas} &= \sum_{i=1}^{s} sk_i \bmod n \\
  pk_{mas} &= \Bigg[ \sum_{i=1}^{s} sk_i \bmod n \Bigg] \cdot G \\
           &= \sum_{i=1}^{s} (sk_i \cdot G) = \sum_{i=1}^{s} pk_i
\end{split}
\end{equation*}

or multiplicatively:

\begin{equation*}
\begin{split}
  sk_{mas} &= \prod_{i=1}^{s} sk_i \bmod n \\
  pk_{mas} &= \Bigg[ \prod_{i=1}^{s} sk_i \bmod n \Bigg] \cdot G \\
           &= (((G \cdot sk_1) \cdot sk_2) \dots )\cdot sk_i
\end{split}
\end{equation*}

In the additive case, the master public key $pk_{mas}$ is also the sum of all the
public points $pk_i$, which means that if each one publish his own public share
point, every one can compute the master public key.

\subsection{Private parent key to private child key}
The function CKDpriv compute a child extended private key from the parent extended
private key. The derivatioin can be \textit{hardened}. This proposal differ from
the BIP32 standard in the chain derivation proccess. The threshold scheme require
the same chain on all participants, so the proccess cannot rely on the private key
share of any participant.

\begin{equation*}
\begin{split}
  f(l) &=
  \begin{cases}
    \text{HMAC-SHA256}(c_{par}, \text{0x00}\mid\mid \text{ser}_{256}(k_{par})
    \mid\mid \text{ser}_{32}(i)) & \quad \text{if } i \geq 2^{31}\\
    \text{HMAC-SHA256}(c_{par}, \text{ser}_{p}(\text{point}(k_{par}))
    \mid\mid \text{ser}_{32}(i)) & \quad \text{if } i < 2^{31}
  \end{cases} \\
  k_i &\equiv l \cdot k_{par} \pmod n
\end{split}
\end{equation*}

\subsection{Public parent key to public child key}
The function CKDpub compute a child extend public key from the parent extended
public key. It is worth noting than it is not possible to compute an
\textit{hardened} derivation without the parent private key.

\begin{equation*}
\begin{split}
  f(l) &=
  \begin{cases}
    \text{failure} & \quad \text{if } i \geq 2^{31}\\
    \text{HMAC-SHA256}(c_{par}, \text{ser}_{p}(K_{par})
    \mid\mid \text{ser}_{32}(i)) & \quad \text{if } i < 2^{31}
  \end{cases} \\
  K_i &= l \cdot K_{par}\\
      &= l \cdot (k_{par} \cdot G)\\
      &= (l \cdot k_{par} \bmod n) \cdot G
\end{split}
\end{equation*}

\subsection{Child key share derivation}
It is asume that one of the participants $P_j$ is designated as the leader $L$.
The function CKSD compute a child extended key share from the parent
extended key share.

\begin{equation*}
\begin{split}
  f(T) &=
  \begin{cases}
    \text{CKDpriv}(i) & \quad \text{if } L = j\\% \land i < 2^{31}
    \text{CKDpub}(i) & \quad \text{if } L \neq j
  \end{cases} \\
  sk_i &= \Bigg[ \prod_{s=1}^{j} sk_{par}^{s} \Bigg] \cdot T \\
       &= sk_{par} \cdot T \\
  pk_i &= pk_{par} \cdot T \\
       &= sk_{par} \cdot G \cdot T \\
       &= \Bigg[ \prod_{s=1}^{j} sk_{par}^{s} \Bigg] \cdot G \\
  c_i &= \text{HMAC-SHA256}(c_{par}, \text{ser}_{32}(i))
\end{split}
\end{equation*}

If the index is greather or equal than $2^{31}$
the public key share of the participants $P_j = L$ need to be
revealed in order to compute the public child key, a round of communication is
needed.

% \begin{equation*}
% \begin{split}
%   f(T) &= \text{CKDpriv}(i) \\
%   sk_i &= \prod_{s=1}^{j} (sk_{par}^{s} \cdot T^s) \\
%   pk_i &= pk_{par} \cdot T \\
%        &= sk_{par} \cdot G \cdot T \\
%        &= \Bigg[ \prod_{s=1}^{j} (sk_{par}^{s} \cdot T^s) \Bigg] \cdot G \\
%   c_i &= \text{HMAC-SHA256}(c_{par}, \text{ser}_{32}(i))
% \end{split}
% \end{equation*}

% \begin{equation*}
% \begin{split}
%   T &= \text{HMAC-SHA512}(c_{par}, \text{ser}_{p}(pk_{par}^{(L)})
%   \mid\mid \text{ser}_{32}(i)) \\
%   pk_i &= pk_{par} + (T \cdot G) \\
%   c_i &= T_R
% \end{split}
% \end{equation*}
%
% \begin{equation*}
% \begin{split}
%   pk_i &= pk_{par} + T
% \end{split}
% \end{equation*}


% -----------------------------------------------------------------------------
\section{Threshold deterministic signature}

How to use an HMAC function in threshold mode to have deterministic $k$ for signature.
