\chapter{ECDSA asymmetric threshold scheme}
\label{chap:threshold}

Threshold cryptography has been discussed for a long time already, many
cryptographic schemes like RSA or Paillier \cite{10.1007/BFb0052253,
10.1007/978-3-642-27954-6_20} exist, but the difficulty is to use them in a real
case application. Since Bitcoin become famous, people have lost funds because they
lose keys or get hacked. Since then research has been done to secure Bitcoin
wallets \cite{Goldfeder2015SecuringBW, DBLP:conf/acns/GennaroGN16}, however, the
most significant problem today in Bitcoin that slows down the adoption of a
threshold cryptosystem is the complexity of creating an efficient and flexible
scheme for \gls{ecdsa}. Recently, researchers have focused on finding more efficient
and more generic systems, but fortunately, a protocol perfectly fulfilling the
needs described in the previous chapter required to improve payment channels in
Bitcoin already exists. Nevertheless, this scheme explains how to perform a
\gls{dsa} threshold signature and not \gls{ecdsa}. So the protocol needs to be
adapted.

The scheme analyzed, transformed, and implemented in the following has been
proposed by MacKenzie and Reiter in their paper \say{Two-Party Generation of DSA
Signatures} \cite{crypto-2001-1592}. This scheme is also the basis of several
other papers previously cited. They base their construction of a threshold signature
scheme with \gls{dsa} based on a simple multiplicative shared secret and
homomorphic encryption to keep the individual values unknown by the other
player. The homomorphic encryption used as an example in the paper and chosen for
the implementation is the Paillier cryptosystem
\cite{Paillier:1999:PCB:1756123.1756146}. The following chapter describes how to
adapt the scheme from \gls{dsa} to \gls{ecdsa} and introduces some fundamental
building blocks needed for a real case scenario like hierarchical deterministic
threshold wallet or deterministic signatures.

\minitoc

\newpage

% -----------------------------------------------------------------------------
\section{Reminder}

Before introducing the threshold scheme, reminders of basic components used in
the scheme are presented. These reminders are composed of \gls{ec} basic
mathematics, Paillier homomorphic encryption scheme, and digital signature
protocols, in particular \gls{dsa} and \gls{ecdsa}.

\subsection{Elliptic curves}

Bitcoin uses \gls{ec} cryptography for securing its transaction. \gls{ecdsa},
based on the \gls{dsa} proposal by the \gls{nist}, over the curve secp256k1,
proposed by the \gls{secg}, is used \cite{sec2}.

\subsubsection{Secp256k1 curve}

The curve secp256k1 is defined over the finite field $\mathbb{F}_p$ of $2^{256}$
bits with a Koblitz curve $y^2 = x^3 + ax + b$ where $a = 0$ and $b = 7$.
\begin{equation*}
\begin{split}
  y^2 &= x^3 + 7\\
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
  p &= &\text{\scriptsize FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F}\\
  G &= &\text{\scriptsize (79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798,}\\
    &  &\text{\scriptsize  483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8)}\\
  n &= &\text{\scriptsize FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141}
\end{split}
\end{equation*}

The curve order $n$ defines the number of elements (points) generated by the
generator $G$ on the curve. Exponentiation of the generator $g^a \mod p$ becomes
a point multiplication with the generator $a \cdot G$.

\subsubsection{Points addition}
With two distinct points $P$ and $Q$ on the curve $\mathcal{E}$, geometrically
the resulting point of the addition is the inverse point, $(x, -y)$ of the
intersection point with a straight line between $P$ and $Q$. An infinity point
$\mathcal{O}$ represents the identity element in the group. Algebraically the
resulting point is obtained with:

\begin{equation}
\begin{split}
  P + Q &= Q + P = P + Q + \mathcal{O} = R \\
  (x_p, y_p) + (x_q, y_q) &= (x_r, y_r) \\
  x_r &\equiv \lambda^2 - x_p - x_q \pmod p \\
  y_r &\equiv \lambda(x_p - x_r) - y_p \pmod p  \\
  \lambda &= \cfrac{y_q - y_p}{x_q - x_p} \\
          &\equiv (y_q - y_p)(x_q - x_p)^{-1} \pmod p
\end{split}
\end{equation}

\subsubsection{Point doubling}

For $P$ and $Q$ equal, the formula is similar, the tangent to the curve
$\mathcal{E}$ at point $P$ determines $R$.

\begin{equation}
\begin{split}
  P + P &= 2P = R \\
  (x_p, y_p) + (x_p, y_p) &= (x_r, y_r) \\
  x_r &\equiv \lambda^2 - 2x_p \pmod p \\
  y_r &\equiv \lambda(x_p - x_r) - y_p \pmod p  \\
  \lambda &= \cfrac{3x_p^2 + a}{2y_p} \\
          &\equiv (3x_p^2 + a)(2y_p)^{-1} \pmod p
\end{split}
\end{equation}

\subsubsection{Point multiplication}

A point $P$ can be multiplied by a scalar $d$. The straightforward way of
computing a point multiplication is through repeated addition where $dP = P_1 +
P_2 + \dots + P_d$.

% However, this is a fully
% exponential approach to computing the multiplication.
% The simplest method is the double-and-add method. To compute
% $dP = P_1 + P_2 + \dots + P_d$, start with the
% binary representation for $d : d = d_0 + 2d_1 + 2^2d_2 + \dots + 2^md_m$,
% where
% $[ d_0 \dots d_m] \in {0,1}$, $N = P, Q = \mathcal{O} \and \forall d_x : \text{if } d_x = 1 Q = \text{add}(Q, P), N = \text{double}(N)$.


\begin{lemma}[Elliptic Curve Discrete Logarithm Problem]
  Given a multiple $Q$ of $P$ where $Q = nP$ it is infeasible to find $n$ if $n$ is large.
\end{lemma}

\begin{lemma}[Point Order]
  A point $P$ has order $2$ if $P + P = \mathcal{O}$, and therefore $P = -P$.
  A point $Q$ has order $3$ if $Q+Q+Q=\mathcal{O}$, and therefore $Q + Q = -Q$.
\end{lemma}


\subsection{Paillier cryptosystem}

\begin{quote}{Wikipedia:}
  The Paillier cryptosystem, invented by and named after Pascal Paillier in 1999,
  is a probabilistic asymmetric algorithm for public key cryptography. The problem
  of computing $n$-th residue classes is believed to be computationally difficult.
  The decisional composite residuosity assumption is the intractability hypothesis
  upon which this cryptosystem is based.
\end{quote}

\subsubsection{Encryption}

With a public key $(n, g)$ and a message $m < n$, select a random $r < n$ and
compute the ciphertext $c = g^m \cdot r^n \mod n^2$ to encrypt the plaintext.

\subsubsection{Decryption}

With a private key $(n, g, \lambda, \mu)$ and a ciphertext $c \in
\mathbb{Z}_{n^2}^*$ compute the plaintext as $m = L(c^{\lambda} \mod n^2) \cdot
\mu \mod n$ where $L(x) = \frac{x-1}{n}$.

\subsection{Signature schemes}
\subsubsection{Digital Signature Algorithm}

\begin{quote}{Wikipedia:}
  The Digital Signature Algorithm (DSA) is a Federal Information Processing Standard
  for digital signatures. In August 1991 the National Institute of Standards and
  Technology (NIST) proposed DSA for use in their Digital Signature Standard (DSS)
  and adopted it as FIPS 186 in 1993.
\end{quote}

\paragraph{Signing}

With public parameters $(p, q, g)$, \texttt{hash} the hashing function,
$m$ the message, and $x \in \mathbb{Z}_q$ the private key.

\begin{itemize}
  \item Generate a random $k \in \mathbb{Z}_q$
  \item Calculate $r \equiv (g^k \pmod p) \pmod q : r \neq 0$
  \item Calculate $s \equiv k^{-1}(\texttt{hash}(m) + xr) \pmod q : s \neq 0$
  \item The signature is $(r, s)$
\end{itemize}

\paragraph{Verifying}

With public parameters $(p, q, g)$, \texttt{hash} the hashing function,
$m$ the message, $(r, s)$ the signature, and $y = g^x \mod p$ the public key.

\begin{itemize}
  \item Reject the signature if $r, s \notin \mathbb{Z}_q$
  \item Calculate $w \equiv s^{-1} \pmod q$
  \item Calculate $u_1 \equiv \texttt{hash}(m) \cdot w \pmod q$
  \item Calculate $u_2 \equiv rw \pmod q$
  \item Calculate $v \equiv (g^{u_1}y^{u_2} \pmod p) \pmod q$
  \item The signature is valid if $v = r$
\end{itemize}

\subsubsection{Elliptic Curve Digital Signature Algorithm}

\gls{ecdsa} is a variant of \gls{dsa} which uses elliptic curve cryptography and
requires a different set of parameters and smaller keys.

\paragraph{Signing}

With public parameters $(\mathcal{E}, G, n)$, \texttt{hash} the hashing function,
$m$ the message, and $x \in \mathbb{Z}_n$ the private key.

\begin{itemize}
  \item Generate a random $k \in \mathbb{Z}_n$
  \item Calculate $(x_1, y_1) = k \cdot G$
  \item Calculate $r \equiv x_1 \pmod n : r \neq 0$
  \item Calculate $s \equiv k^{-1}(\texttt{hash}(m) + xr) \pmod n : s \neq 0$
  \item The signature is $(r, s)$
\end{itemize}

\paragraph{Verifying}

With public parameters $(\mathcal{E}, G, n)$, \texttt{hash} the hashing function,
$m$ the message, $(r, s)$ the signature, and $Q = x \cdot G$ the public key.

\begin{itemize}
  \item Reject the signature if $r, s \notin \mathbb{Z}_n$
  \item Calculate $w \equiv s^{-1} \pmod n$
  \item Calculate $u_1 \equiv \texttt{hash}(m) \cdot w \pmod n$
  \item Calculate $u_2 \equiv rw \pmod n$
  \item Calculate the curve point $(x_1, y_1) = u_1 \cdot G + u_2 \cdot Q$ if
  $(x_1, y_1) = \mathcal{O}$ then the signature is invalid
  \item The signature is valid if $r \equiv x_1 \pmod n$
\end{itemize}

\subsubsection{Schemes' analysis}

In $(r, s)$ the computation of the part $s$ remains the same in each signature
scheme, the only difference for $s$ is the modulus applied. In \gls{dsa} the
modulus $q$ is took, i.e. the order of the generator $g$ modulo $p$,  while in
\gls{ecdsa} the modulus $n$ is took, i.e. the order of the generator $G$ on the
curve $\mathcal{E}$.

The biggest adaptation is on how to calculate the part $r$ from the private
random $k$. In \gls{dsa} the generator $g$ is used with, at first, modulo $p$
and then modulo $q$ while in \gls{ecdsa} the curve is used. The signer generates
a point and uses the coordinate $x_1$ modulo $n$.

\begin{postulate}
  This statement $a \equiv g^b \pmod p$ is equivalent in terms of security to $a = b \cdot G$
  and $a \equiv (g^b \pmod p) \pmod q$ is equivalent to $a \equiv x \pmod n : (x, y) = b \cdot G$.
  \label{post:adaptEcdsa}
\end{postulate}

The previous postulate is used to adapt zero-knowledge proofs from \gls{dsa} to
\gls{ecdsa} hereafter. Lack of time has not permitted further research into this
postulate.


% -----------------------------------------------------------------------------
\section{Threshold scheme}

The \say{Two-party generation of DSA signatures} scheme presented by MacKenzie
and Reiter, as mentioned before, is an asymmetric scheme, i.e., at the end of
the protocol, only the initiator can retrieve the full signature. The scheme
proposed is a cryptographic (1,2)-threshold, i.e., one corrupted player can
occur out of the two players, and the scheme remains safe. It is worth noting that
this is qualified as an optimal $(t, n)$-threshold scheme, i.e., $t = n - 1$
because if only one honest player remains the safety is guaranteed.

As also mentioned before, the scheme adheres to the same requirements as a
Bitcoin 2-out-of-2 multi-signature script. This means that it is possible to
use it to improve the payment channels. However, it is necessary to adapt the
scheme and particularly the construction of the zero-knowledge proofs. The following
explains the chosen adaptation.

The presented scheme in the original paper uses a multiplicative shared secret
and a multiplicative shared private random value. The secret $x$ is shared
between Alice and Bob, so that Alice holds the secret value $x_1 \in
\mathbb{Z}_{q}$ and Bob $x_2 \in \mathbb{Z}_{q}$ such that $x \equiv x_1x_2
\pmod q$. Along with the public key $y$, $y_1 \equiv g^{x_1} \pmod p$ and $y_2
\equiv g^{x_2} \pmod p$ are public. Alice holds a private key, from now on
mentioned as $sk$, corresponding to a public encryption key $pk$. Alice also
knows a public encryption key $pk'$ for which she does not know the private key
$sk'$. Here the Paillier homomorphic cryptosystem is used as the encryption
scheme, but it is worth noting that other homomorphic encryption systems can be
used to implement the scheme. Alice and Bob know a set of parameters used for
both zero-knowledge proofs.

Starting now the initialization is not taken into account, and the author
assumes that reader has a good understanding of the original scheme
\cite{crypto-2001-1592}. The choice was made to focus the work on the
signing protocol and because the implementation is not directly part of the
cryptographic \texttt{C} library. This initialization can be further researched
for another thesis.

\subsection{Adapting the scheme}

Except for the zero-knowledge proofs, the adaptation is trivial and just requires
the same adaptation of the \gls{dsa} signature scheme and \gls{ecdsa} signature
scheme, i.e., compute the $r$ value with the curve. The following figures
describe the adapted scheme. The adapted protocol keeps the same messages, so
they are not repeated. The postulate~\ref{post:adaptEcdsa} is used to perform
the adaptation.

The secret remains shared multiplicatively so that so that Alice holds the secret
value $x_1 \in \mathbb{Z}_{n}$ and Bob $x_2 \in \mathbb{Z}_{n}$ such that $x
\equiv x_1x_2 \pmod n$. Alice holds her public key $Q_1 = x_1 \cdot G$ and Bob
$Q_2 = x_2 \cdot G$ such that $Q = x_1 \cdot Q_2$ for Alice or $Q = x_2 \cdot
Q_1$ for Bob. The notation $\cdot$ is used to denote the point multiplication
over \gls{ec}.

All the random values $k$ are chosen in $\mathbb{Z}_{n}$ instead of
$\mathbb{Z}_{q}$, also in the case of deterministic signature. All the
computation modulo $q$ is replaced by modulo $n$, as shown in the previous
digital signature recap. Values $R_2$ and $R$ become points. Verifications of
values $R_2$ and $R$ become point verifications on the curve and $r'$ is
calculated by Alice and Bob as shown in the other reminder. The value $cq$ added
to the homomorphic encrypted signature is transformed into $cn$ to hide values
$z_2$ and $x_2z_2$.

The author noticed an error of notation in the original paper. On the second
line Alice computes $z_1 \equiv (k_1)^{-1} \pmod n$ and the original paper uses
the random value selection $\xleftarrow[]{R}$ instead of a standard assignation
$\leftarrow$. This error is corrected in the following version of the protocol.

\newpage

\begin{figure}[H]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      {\renewcommand{\arraystretch}{1.2}%
      \begin{tabular}{ | l l | }
        \hline
        \multicolumn{1}{|c}{alice}  & \multicolumn{1}{c|}{bob} \\
        $k_1 \xleftarrow[]{R} \mathbb{Z}_{n}$ & \\
        $z_1 \leftarrow (k_1)^{-1} \mod n$ & \\
        $\alpha \leftarrow E_{pk}(z_1)$ & \\
        $\zeta \leftarrow E_{pk}(x_1z_1 \mod n)$ & \\[2ex]
          & abort if($\alpha \notin C_{pk} \lor \zeta \notin C_{pk}$) \\
          & $k_2 \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
          & $\mathcal{R}_2 \leftarrow k_2 \cdot \mathcal{G}$ \\[2ex]
        abort if($\mathcal{R}_2 \notin \mathcal{E}$) & \\
        $\mathcal{R} \leftarrow k_1 \cdot \mathcal{R}_2$ & \\
        \multicolumn{2}{|l|}{
        $\Pi \leftarrow \texttt{zkp} \begin{bmatrix}\begin{array}{lr}
                                      \exists \eta_1, \eta_2 : & \eta_1, \eta_2 \in [-n^3, n^3] \\
                                      \land & \eta_1 \cdot \mathcal{R} = \mathcal{R}_2 \\
                                      \land & (\eta_2/\eta_1) \cdot \mathcal{G} = \mathcal{Q}_1 \\
                                      \land & D_{sk}(\alpha) \equiv_n \eta_1 \\
                                      \land & D_{sk}(\zeta) \equiv_n \eta_2
                                     \end{array}\end{bmatrix}$ } \\ & \\
          & abort if($\mathcal{R} \notin \mathcal{E}$) \\
          & abort if(\texttt{Verifier}$(\Pi) = 0$) \\
          & $m' \leftarrow \texttt{h}(m)$ \\
          & $r' \leftarrow x \mod n : (x,y) = \mathcal{R}$ \\
          & $z_2 \leftarrow (k_2)^{-1} \mod n$ \\
          & $c \xleftarrow[]{R} \mathbb{Z}_{n^5}$ \\
          & $\begin{aligned}[t]
              \mu \leftarrow & (\alpha \times_{pk} m'z_2) +_{pk} \\
                             & (\zeta \times_{pk} r'x_2z_2) +_{pk} E_{pk}(cn)
            \end{aligned}$ \\
          & $\mu' \leftarrow E_{pk'}(z_2)$ \\
          & {$\Pi' \leftarrow \texttt{zkp} \begin{bmatrix}\begin{array}{lr}
                                            \exists \eta_1, \eta_2, \eta_3 : & \eta_1, \eta_2 \in [-n^3, n^3] \\
                                            \land & \eta_3 \in [-n^5, n^5] \\
                                            \land & \eta_1 \cdot \mathcal{R}_2 = \mathcal{G} \\
                                            \land & (\eta_2/\eta_1) \cdot \mathcal{G} = \mathcal{Q}_2 \\
                                            \land & D_{sk'}(\mu') \equiv_n \eta_1 \\
                                            \multicolumn{2}{l}{
                                              \begin{aligned}[t]
                                                  \land \quad D_{sk}(\mu) \equiv_n & D_{sk}((\alpha \times_{pk} m'\eta_1) +_{pk} \\
                                                                                   & (\zeta \times_{pk} r'\eta_2) +_{pk} E_{pk}(n\eta_3))
                                                \end{aligned}
                                            }
                                           \end{array}\end{bmatrix}$} \\ & \\
        abort if($\mu \notin C_{pk} \lor \mu' \notin C_{pk'}$) & \\
        abort if(\texttt{Verifier}$(\Pi') = 0$) & \\
        $s \leftarrow D_{sk}(\mu) \mod n$ & \\
        $r \leftarrow x \mod n : (x,y) = \mathcal{R}$ & \\
        publish <$r$, $s$> & \\
        \hline
      \end{tabular}}
      \end{footnotesize}
    \end{table}

  \caption{Adapted protocol for ECDSA}
  \label{fig:adaptationSchemeECDSA}
\end{figure}

\subsection{Adapting zero-knowledge proofs}

Initially, the protocol designs proofs for the DSA architecture, so the values
tested in the proofs are values in $\mathbb{Z}_{q}$. These values are used to
create a challenge $e$ with two hash functions, a different one per proof. For
ECDSA some of these values become points, so some equations need to be adapted.
The adapted protocol serializes points in the long form, 65 bytes starting with
\texttt{0x04}, and two 32 byte coordinates for $(x, y)$. As mentioned in the
original paper, the variables names are not consistent with the first part of
the paper. Starting now the variable names follow the same notation as the
original paper and are therefore no longer consistent with the previous pages.

\subsubsection{Zero-knowledge proof $\Pi$}

The first zero-knowledge proof $\Pi$ is created by Alice to prove to Bob that
she acted correctly and has encrypted coherent data with Paillier encryption,
proving the ownership and the validity of the two encrypted values in relation
to the public address $Q_1$ with $(x_1z_1 / z_1) \cdot G = Q_1$. The proof
states that the encrypted value $\alpha$ is related to $R$ and $R_2$ such that
$(k_1)^{-1} \cdot R = ((k_1)^{-1}k_1k_2) \cdot G = k_2 \cdot G = R_2$.

\begin{figure}[h]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
        \[
        \Pi \leftarrow \texttt{zkp} \begin{bmatrix}\begin{array}{lr}
                                      \exists x_1, x_2 : & x_1, x_2 \in [-n^3, n^3] \\
                                      \land & x_1 \cdot \mathcal{C} = \mathcal{W}_1 \\
                                      \land & (x_2/x_1) \cdot \mathcal{D} = \mathcal{W}_2 \\
                                      \land & D_{sk}(m_1) \equiv_n x_1 \\
                                      \land & D_{sk}(m_2) \equiv_n x_2
                                     \end{array}\end{bmatrix}
        \]
      \end{footnotesize}
    \end{table}

  \caption{The proof $\Pi$}
  \label{fig:theProofPi}
\end{figure}

\begin{table}[h]
  \begin{tabular}{p{4cm} l}
    $x_1 = z_1$ & $\mathcal{C} = \mathcal{R}$ \\
    $x_2 = x_1z_1 \mod n$ & $\mathcal{D} = \mathcal{G}$ \\
    $m_1 = \alpha$ & $\mathcal{W}_1 = \mathcal{R}_2$ \\
    $m_2 = \zeta$ & $\mathcal{W}_2 = \mathcal{Q}_1$
  \end{tabular}
  \caption{Mapping between the protocol's variable names and the ZKP $\Pi$}
  \label{fig:mappingOfVarNamesPi}
\end{table}

\begin{figure}[h]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      \begin{tabular}{ | p{6cm} p{6cm} | }
        \hline
        \multicolumn{2}{ | c | }{$\langle z_1, z_2, \mathcal{Y}, e, s_1, s_2, s_3, t_1, t_2, t_3, t_4 \rangle \leftarrow \Pi$} \\
          & \\
        $\text{Verify } s_1, t_1 \in \mathbb{Z}_{n^3}$ & $\mathcal{V}_1 \leftarrow (t_1 + t_2) \cdot \mathcal{D} + (-e) \cdot \mathcal{Y}$ \\
        $\mathcal{U}_1 \leftarrow s_1 \cdot \mathcal{C} + (-e) \cdot \mathcal{W}_1$ & $\mathcal{V}_2 \leftarrow s_1 \cdot \mathcal{W}_2 + t_2 \cdot \mathcal{D} + (-e) \cdot \mathcal{Y}$ \\
        $u_2 \leftarrow g^{s_1}(s_2)^N(m_1)^{-e} \mod N^2$ & $v_3 \leftarrow g^{t_1} (t_3)^N (m_2)^{-e} \mod N^2$ \\
        $u_3 \leftarrow (h_1)^{s_1} (h_2)^{s_3} (z_1)^{-e} \mod \tilde{N}$ & $v_4 \leftarrow (h_1)^{t_1} (h_2)^{t_4} (z_2)^{-e} \mod \tilde{N}$ \\
         & \\
        \multicolumn{2}{|c|}{$\text{Verify } e = \texttt{hash}(\mathcal{C}, \mathcal{W}_1, \mathcal{D}, \mathcal{W}_2, m_1, m_2, z_1, \mathcal{U}_1, u_2, u_3, z_2, \mathcal{Y}, \mathcal{V}_1, \mathcal{V}_2, v_3, v_4)$} \\
        \hline
      \end{tabular}
      \end{footnotesize}
    \end{table}

  \caption{Adaptation of $\Pi$'s verification in ECDSA}
  \label{fig:adaptationOfPiVerification}
\end{figure}

\begin{figure}[h]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      \begin{tabular}{ | p{5cm} p{5cm} | }
        \hline
        $\alpha \xleftarrow[]{R} \mathbb{Z}_{n^3}$ & $\delta \xleftarrow[]{R} \mathbb{Z}_{n^3}$ \\
        $\beta \xleftarrow[]{R} \mathbb{Z}_{N}^{*}$ & $\mu \xleftarrow[]{R} \mathbb{Z}_{N}^{*}$ \\
        $\gamma \xleftarrow[]{R} \mathbb{Z}_{n^{3}\tilde{N}}$ & $\nu \xleftarrow[]{R} \mathbb{Z}_{n^{3}\tilde{N}}$ \\
        $\rho_1 \xleftarrow[]{R} \mathbb{Z}_{n\tilde{N}}$ & $\rho_2 \xleftarrow[]{R} \mathbb{Z}_{n\tilde{N}}$ \\
         & $\rho_3 \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
         & $\epsilon \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
         & \\
        $z_1 \leftarrow (h_1)^{x_1}(h_2)^{\rho_1} \mod \tilde{N}$ & $z_2 \leftarrow (h_1)^{x_2}(h_2)^{\rho_2} \mod \tilde{N}$ \\
        $\mathcal{U}_1 \leftarrow \alpha \cdot \mathcal{C}$ & $\mathcal{Y} \leftarrow (x_2 + \rho_3) \cdot \mathcal{D}$ \\
        $u_2 \leftarrow g^{\alpha} \beta^{N} \mod N^2$ & $\mathcal{V}_1 \leftarrow (\delta + \epsilon) \cdot \mathcal{D}$ \\
        $u_3 \leftarrow (h_1)^{\alpha} (h_2)^{\gamma} \mod \tilde{N}$ & $\mathcal{V}_2 \leftarrow \alpha \cdot \mathcal{W}_2 + \epsilon \cdot \mathcal{D}$ \\
         & $v_3 \leftarrow g^{\delta} \mu^{N} \mod N^2$ \\
         & $v_4 \leftarrow (h_1)^{\delta} (h_2)^{\nu} \mod \tilde{N}$ \\
         & \\
        \multicolumn{2}{|l|}{$e \leftarrow \texttt{hash}(\mathcal{C}, \mathcal{W}_1, \mathcal{D}, \mathcal{W}_2, m_1, m_2, z_1, \mathcal{U}_1, u_2, u_3, z_2, \mathcal{Y}, \mathcal{V}_1, \mathcal{V}_2, v_3, v_4)$} \\
         & \\
        $s_1 \leftarrow ex_1 + \alpha$ & $t_1 \leftarrow ex_2 + \delta$ \\
        $s_2 \leftarrow (r_1)^e \beta \mod N$ & $t_2 \leftarrow e \rho_3 + \epsilon \mod n$ \\
        $s_3 \leftarrow e \rho_1 + \gamma$ & $t_3 \leftarrow (r_2)^e \mu \mod N^2$ \\
         & $t_4 \leftarrow e \rho_2 + \nu$ \\
         & \\
        \multicolumn{2}{ | c | }{$\Pi \leftarrow \langle z_1, z_2, \mathcal{Y}, e, s_1, s_2, s_3, t_1, t_2, t_3, t_4 \rangle$} \\
        \hline
      \end{tabular}
      \end{footnotesize}
    \end{table}

  \caption{Adaptation of $\Pi$'s construction in ECDSA}
  \label{fig:adaptationOfPi}
\end{figure}

\subsubsection{Zero-knowledge proof $\Pi'$}

The second zero-knowledge proof is created by Bob to prove to Alice that he
acted honestly according to the protocol. The proof states that the point
$\mathcal{R}_2$ is generated accordingly to the value $z_2$ and so to the value
$k_2$. That the public key $\mathcal{Q}_2$ is related to the values $z_2$ and
$x_2z_2$, and that the encrypted values $\mu$ and $\mu'$ are correctly composed.

\begin{table}[h]
  \begin{tabular}{p{4cm} l}
    $x_1 = z_2$ & $\mathcal{C} = \mathcal{R}_2$ \\
    $x_2 = x_2z_2 \mod n$ & $\mathcal{D} = \mathcal{G}$ \\
    $x_3 = c \mod n$ & $\mathcal{W}_1 = \mathcal{G}$ \\
    $m_1 = \mu'$ & $\mathcal{W}_2 = \mathcal{Q}_2$ \\
    $m_2 = \mu$ & $m_3 = \alpha$ \\
    $m_4 = \zeta$ &
  \end{tabular}
  \caption{Mapping between the protocol's variable names and the ZKP $\Pi'$}
  \label{fig:mappingOfVarNamesPi2}
\end{table}

\begin{figure}[h]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
        \[
        \Pi' \leftarrow \texttt{zkp} \begin{bmatrix}\begin{array}{lr}
                                          \exists x_1, x_2, x_3 : & x_1, x_2 \in [-n^3, n^3] \\
                                          \land & x_3 \in [-n^5, n^5] \\
                                          \land & x_1 \cdot \mathcal{C} = \mathcal{W}_1 \\
                                          \land & (x_2/x_1) \cdot \mathcal{D} = \mathcal{W}_2 \\
                                          \land & D_{sk'}(m_1) \equiv_n x_1 \\
                                          \multicolumn{2}{l}{
                                            \begin{aligned}[t]
                                                \land \quad D_{sk}(m_2) \equiv_n & D_{sk}((m_3 \times_{pk} m'x_1) +_{pk} \\
                                                                                 & (m_4 \times_{pk} r'x_2) +_{pk} E_{pk}(nx_3))
                                              \end{aligned}
                                          }
                                         \end{array}\end{bmatrix}
        \]
      \end{footnotesize}
    \end{table}

  \caption{The proof $\Pi'$}
  \label{fig:theProofPi2}
\end{figure}

\paragraph{Correcting the verification of $\Pi'$}
If $x_1 = z_2$, $x_2 = x_2 z_2$, $x_3 = c$, and $m_2 = \mu$ such that $\mu =
(\alpha)^{m' x_1} (\zeta)^{r' x_2} g^{nx_3} (r_2)^{N}$, then the equation $v_3$
in the validation proccess does not correspond to construction of $v_3$ in the
original paper. The result in the verification proccess $\Pi'$ need to match
$v_3 \leftarrow (m_3)^{\alpha} (m_4)^{\delta} g^{n \sigma} \mu^{N} \mod N^2$.
The original equation proposed $v_3 \leftarrow (m_3)^{s_1} (m_4)^{t_1} g^{nt_5}
(t_3)^{N} (m_2)^{-e} \mod N^2$ does not include $m'$ and $r'$ present in $\mu$,
so $m_2$ cannot be used correctly as showed next.

\begin{equation}
\begin{split}
   v_3 &\equiv (m_3)^{s_1} (m_4)^{t_1} g^{nt_5} (t_3)^{N} (m_2)^{-e} \pmod{N^2} \\
       &\equiv (m_3)^{ex_1 + \alpha} (m_4)^{ex_2 + \beta} g^{n(ex_3 + \sigma)}
       \big((r_2)^e \mu\big)^{N}
       \big((m_3)^{m' x_1} (m_4)^{r' x_2} g^{nx_3} (r_2)^{N}\big)^{-e} \\
       &\equiv (m_3)^{ex_1 + \alpha} (m_4)^{ex_2 + \beta} g^{n(ex_3 + \sigma)}
       (r_2)^{eN} \mu^{N}
       (m_3)^{-e m' x_1} (m_4)^{-e r' x_2} g^{-e nx_3} (r_2)^{-eN} \\
       &\equiv (m_3)^{ex_1 + \alpha - e m' x_1} (m_4)^{ex_2 + \beta - e r' x_2}
       g^{enx_3 + n\sigma - enx_3} (r_2)^{eN - eN} \mu^{N}  \\
       &\equiv (m_3)^{ex_1 + \alpha - e m' x_1} (m_4)^{ex_2 + \beta - e r' x_2}
       g^{n\sigma} \mu^{N}  \\
\end{split}
\end{equation}

The equation $v_3$ needs to be adapted to include $x_4 = m'$ and $x_5 = r'$
($m'$ and $r'$ cannot be include directly in $x_1$ and $x_2$ without breaking
equations $u_1, u_2, u_3, v_2$.) Two new parameters $s_4 \leftarrow ex_1 x_4 +
\alpha$ and $t_7 \leftarrow ex_2 x_5 + \delta$ are added into the proof to
correct the equation.

\begin{equation}
\begin{split}
   v_3 &\equiv (m_3)^{s_4} (m_4)^{t_7} g^{nt_5} (t_3)^{N} (m_2)^{-e} \pmod{N^2} \\
       &\equiv (m_3)^{ex_1x_4 + \alpha} (m_4)^{ex_2x_5 + \beta} g^{n(ex_3 + \sigma)}
       \big((r_2)^e \mu\big)^{N}
       \big((m_3)^{x_1x_4} (m_4)^{x_2x_5} g^{nx_3} (r_2)^{N}\big)^{-e} \\
       &\equiv (m_3)^{ex_1x_4 + \alpha} (m_4)^{ex_2x_5 + \beta} g^{n(ex_3 + \sigma)}
       (r_2)^{eN} \mu^{N}
       (m_3)^{-e x_1x_4} (m_4)^{-e x_2x_5} g^{-e nx_3} (r_2)^{-eN} \\
       &\equiv (m_3)^{ex_1x_4 + \alpha - e x_1x_4} (m_4)^{ex_2x_5 + \beta - e x_2x_5}
       g^{enx_3 + n\sigma - enx_3} (r_2)^{eN - eN} \mu^{N}  \\
       &\equiv (m_3)^{\alpha} (m_4)^{\beta} g^{n\sigma} \mu^{N} \\
\end{split}
\end{equation}


\begin{figure}[ht]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      \begin{tabular}{ | p{5.5cm} p{6cm} | }
        \hline
        $\alpha \xleftarrow[]{R} \mathbb{Z}_{n^3}$ & $\delta \xleftarrow[]{R} \mathbb{Z}_{n^3}$ \\
        $\beta \xleftarrow[]{R} \mathbb{Z}_{N'}^{*}$ & $\mu \xleftarrow[]{R} \mathbb{Z}_{N}^{*}$ \\
        $\gamma \xleftarrow[]{R} \mathbb{Z}_{n^{3}\tilde{N}}$ & $\nu \xleftarrow[]{R} \mathbb{Z}_{n^{3}\tilde{N}}$ \\
        $\rho_1 \xleftarrow[]{R} \mathbb{Z}_{n\tilde{N}}$ & $\rho_2 \xleftarrow[]{R} \mathbb{Z}_{n\tilde{N}}$ \\
         & $\rho_3 \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
         & $\rho_4 \xleftarrow[]{R} \mathbb{Z}_{n^5\tilde{N}}$ \\
         & $\epsilon \xleftarrow[]{R} \mathbb{Z}_{n}$ \\
         & $\sigma \xleftarrow[]{R} \mathbb{Z}_{n^7}$ \\
         & $\tau \xleftarrow[]{R} \mathbb{Z}_{n^7\tilde{N}}$ \\
         & \\
        $z_1 \leftarrow (h_1)^{x_1}(h_2)^{\rho_1} \mod \tilde{N}$ & $z_2 \leftarrow (h_1)^{x_2}(h_2)^{\rho_2} \mod \tilde{N}$ \\
        $\mathcal{U}_1 \leftarrow \alpha \cdot \mathcal{C}$ & $\mathcal{Y} \leftarrow (x_2 + \rho_3) \cdot \mathcal{D}$ \\
        $u_2 \leftarrow (g')^{\alpha} \beta^{N'} \mod (N')^2$ & $\mathcal{V}_1 \leftarrow (\delta + \epsilon) \cdot \mathcal{D}$ \\
        $u_3 \leftarrow (h_1)^{\alpha} (h_2)^{\gamma} \mod \tilde{N}$ & $\mathcal{V}_2 \leftarrow \alpha \cdot \mathcal{W}_2 + \epsilon \cdot \mathcal{D}$ \\
         & $v_3 \leftarrow (m_3)^{\alpha} (m_4)^{\delta} g^{n \sigma} \mu^{N} \mod N^2$ \\
         & $v_4 \leftarrow (h_1)^{\delta} (h_2)^{\nu} \mod \tilde{N}$ \\
         & $z_3 \leftarrow (h_1)^{x_3} (h_2)^{\rho_4} \mod \tilde{N}$ \\
         & $v_5 \leftarrow (h_1)^{\sigma} (h_2)^{\tau} \mod \tilde{N}$ \\
         & \\
        \multicolumn{2}{ | l | }{$e \leftarrow \texttt{hash'}(\mathcal{C}, \mathcal{W}_1, \mathcal{D}, \mathcal{W}_2, m_1, m_2, z_1, \mathcal{U}_1, u_2, u_3, z_2, z_3, \mathcal{Y}, \mathcal{V}_1, \mathcal{V}_2, v_3, v_4, v_5)$} \\
         & \\
        $s_1 \leftarrow ex_1 + \alpha$ & $t_1 \leftarrow ex_2 + \delta$ \\
        $s_2 \leftarrow (r_1)^e \beta \mod N'$ & $t_2 \leftarrow e \rho_3 + \epsilon \mod n$ \\
        $s_3 \leftarrow e \rho_1 + \gamma$ & $t_3 \leftarrow (r_2)^e \mu \mod N$ \\
        $s_4 \leftarrow ex_1 x_4 + \alpha$ & $t_4 \leftarrow e \rho_2 + \nu$ \\
         & $t_5 \leftarrow e x_3 + \sigma$ \\
         & $t_6 \leftarrow e \rho_4 + \tau$ \\
         & $t_7 \leftarrow ex_2 x_5 + \delta$ \\
         & \\
        \multicolumn{2}{ | c | }{$\Pi' \leftarrow \langle z_1, z_2, z_3, \mathcal{Y}, e, s_1, s_2, s_3, s_4, t_1, t_2, t_3, t_4, t_5, t_6, t_7 \rangle$} \\
        \hline
      \end{tabular}
      \end{footnotesize}
    \end{table}

  \caption{Adaptation of $\Pi'$'s construction in ECDSA}
  \label{fig:adaptationOfPi2}
\end{figure}


\begin{figure}[ht]
    \begin{table}[H]
      \centering
      \begin{footnotesize}
      \begin{tabular}{ | p{6cm} p{6cm} | }
        \hline
        \multicolumn{2}{ | c | }{$\langle z_1, z_2, z_3, \mathcal{Y}, e, s_1, s_2, s_3, s_4, t_1, t_2, t_3, t_4, t_5, t_6, t_7 \rangle \leftarrow \Pi'$} \\
          & \\
        $\text{Verify } s_1, t_1 \in \mathbb{Z}_{n^3}$ & $\mathcal{V}_1 \leftarrow (t_1 + t_2) \cdot \mathcal{D} + (-e) \cdot \mathcal{Y}$ \\
        $\text{Verify } t_5 \in \mathbb{Z}_{n^7}$ & $\mathcal{V}_2 \leftarrow s_1 \cdot \mathcal{W}_2 + t_2 \cdot \mathcal{D} + (-e) \cdot \mathcal{Y}$ \\

        $\mathcal{U}_1 \leftarrow s_1 \cdot \mathcal{C} + (-e) \cdot \mathcal{W}_1$ &
        $\begin{aligned}[t]
            v_3 \leftarrow & (m_3)^{s_4} (m_4)^{t_7} g^{nt_5} (t_3)^{N} (m_2)^{-e} \\
                           &\mod N^2
          \end{aligned}$ \\
        $u_2 \leftarrow (g')^{s_1} (s_2)^{N'} (m_1)^{-e} \mod (N')^2$ & $v_4 \leftarrow (h_1)^{t_1} (h_2)^{t_4} (z_2)^{-e} \mod \tilde{N}$ \\
        $u_3 \leftarrow (h_1)^{s_1} (h_2)^{s_3} (z_1)^{-e} \mod \tilde{N}$ &  $v_5 \leftarrow (h_1)^{t_5} (h_2)^{t_6} (z_3)^{-e} \mod \tilde{N}$\\
         & \\
        \multicolumn{2}{ | c | }{$\text{Verify } e = \texttt{hash'}(\mathcal{C}, \mathcal{W}_1, \mathcal{D}, \mathcal{W}_2, m_1, m_2, z_1, \mathcal{U}_1, u_2, u_3, z_2, z_3, \mathcal{Y}, \mathcal{V}_1, \mathcal{V}_2, v_3, v_4, v_5)$} \\
        \hline
      \end{tabular}
      \end{footnotesize}
    \end{table}

  \caption{Adaptation of $\Pi'$ verification to ECDSA}
  \label{fig:adaptationOfPi2Verification}
\end{figure}

\vfill
\newpage


% -----------------------------------------------------------------------------
\section{Threshold Hierarchical Determinitic Wallets}

Hierarchical deterministic wallets are sophisticated wallets in which new keys
can be generated from a previous key. Adapting hierarchical deterministic
wallets with a threshold scheme can be achieved by sharing the private key
additively:

\begin{equation*}
\begin{split}
  pk_i     &= sk_i \cdot G \\
  sk_{mas} &= \sum_{i=1}^{s} sk_i \bmod n \\
  pk_{mas} &= \Bigg[ \sum_{i=1}^{s} sk_i \bmod n \Bigg] \cdot G \\
           &= \sum_{i=1}^{s} (sk_i \cdot G) = \sum_{i=1}^{s} pk_i
\end{split}
\end{equation*}

or multiplicatively:

\begin{equation*}
\begin{split}
  sk_{mas} &= \prod_{i=1}^{s} sk_i \bmod n \\
  pk_{mas} &= \Bigg[ \prod_{i=1}^{s} sk_i \bmod n \Bigg] \cdot G \\
           &= (((G \cdot sk_1) \cdot sk_2) \dots )\cdot sk_i
\end{split}
\end{equation*}

In the additive case, the master public key $pk_{mas}$ is also the sum of all
the points $pk_i$, which means that if each player publishes his share point,
everyone can compute the master public key. The multiplicative sharing is more
communication applicant because the computation of the public key is sequential
instead of parallel.

An extended private key share is a tuple of $(sk_i, c)$ with $sk_i$ the regular
private key and $c$ the chain code, such that $c$ is the same for each player.
In the following, it is assumed that the private key is shared multiplicatively.

\subsection{Private parent key to private child key}

The function \texttt{CKDpriv} computes a child extended private key from the
parent extended private key. The derivation can be \textit{hardened}. This
proposal differs from the \texttt{BIP32} \cite{HDWallets} standard in the chain
derivation proccess. The \texttt{ser} function and \texttt{point} function are
the same as described in \gls{bip}.

\begin{equation*}
\begin{split}
  f(l) &=
  \begin{cases}
    \texttt{HMAC-SHA256}(c_{par}, \texttt{0x00}\mid\mid \texttt{ser}_{256}(sk_i^{par}) \mid\mid \texttt{ser}_{32}(k)) & \quad \text{if } k \geq 2^{31}\\
    \texttt{HMAC-SHA256}(c_{par}, \texttt{ser}_{p}(\texttt{point}(sk_{mas}^{par})) \mid\mid \texttt{ser}_{32}(k)) & \quad \text{if } k < 2^{31}
  \end{cases} \\
  sk_i &\equiv l \cdot sk_i^{par} \pmod n
\end{split}
\end{equation*}

The function $f(l)$ computes the partial share $l$ at index $k$, such that
multiplied with the parent private key share $sk_i^{par}$ for the player $i$ the
result is $sk_i$.

\subsection{Public parent key to public child key}

The function \texttt{CKDpub} computes a child extend public key from the parent
extended public key. It is worth noting that it is not possible to compute a
\textit{hardened} derivation without the private parent key. It is worth noting
that every player updates the master public key for the threshold, not the
public key share.

\begin{equation*}
\begin{split}
  f(l) &=
  \begin{cases}
    \texttt{failure} & \quad \text{if } k \geq 2^{31}\\
    \texttt{HMAC-SHA256}(c_{par}, \texttt{ser}_{p}(pk_{mas}^{par}) \mid\mid \texttt{ser}_{32}(k)) & \quad \text{if } k < 2^{31}
  \end{cases} \\
  pk_{mas} &= l \cdot pk_{mas}^{par}\\
      &= l \cdot (sk_{mas}^{par} \cdot G)\\
      &= (l \cdot sk_{mas}^{par} \bmod n) \cdot G
\end{split}
\end{equation*}

\subsection{Child key share derivation}

The protocol assumes that one of the players $P_i$ is designated as the leader
$L$. The function \texttt{CKSD} computes a threshold child extended key share
from the threshold parent extended key share for the derivation index $k$. It is
worth noting that only the leader $L$ uses \texttt{CKDpriv} and if the derivation
is \textit{hardened}, i.e., if $k \geq 2^{31}$, a special case occurred and a
round of communication is needed. Let's define \texttt{CKSD} for $k < 2^{31}$:

\begin{equation}
\begin{split}
  \forall i \in P_i : f(t) &=
  \begin{cases}
    \texttt{CKDpriv}(k) & \quad \text{if } i = L\\% \land i < 2^{31}
    \texttt{CKDpub}(k) & \quad \text{if } i \neq L
  \end{cases}
\end{split}
\end{equation}

such that:

\begin{equation}
\begin{split}
  sk_{i = L} &= sk_{i}^{par} \cdot t \\
  sk_{i \neq L} &= sk_{i}^{par} \\
  sk_{mas} &= \Bigg[ \prod_{j=1}^{i} sk_{j}^{par} \Bigg] \cdot t \\
       &= sk_{mas}^{par} \cdot t
\end{split}
\end{equation}

and then $\forall i \in P_i$:

\begin{equation}
\begin{split}
  pk_{mas} &= pk_{mas}^{par} \cdot t \\
       &= (sk_{mas}^{par} \cdot G) \cdot t \\
       &= \Bigg[ \prod_{j=1}^{i} sk_{j}^{par} \Bigg] \cdot G
\end{split}
\end{equation}

At each derivation index, each player updates their chain code. The derivation
does not depend on the secret key because the chain code must remain
deterministic and have the same value for each player, without requiring
communication round.

\begin{equation}
\begin{split}
  c_i &= \texttt{HMAC-SHA256}(c_i^{par}, \texttt{ser}_{32}(k))
\end{split}
\end{equation}

If the index $k \geq 2^{31}$ the new master public key, only calculable by the
master player $L$, must be revealed to other players. A round of communication
is then needed to continue derivation.

In this threshold HD scheme only one private share changes at each derivation. In
other words, the master private share is derived either with public information
or with private information, i.e., \textit{hardened} derivation. If the
derivation is private, then a communication round between the players is
necessary, more specifically we assume that a secure broadcast channel is open
from the master player to the other players.

This scheme is sufficient for the payment channels. Players negotiate a
threshold key used for the $\texttt{Multisig}_i$ address with a root derivation
path \texttt{m/44'/0'/a'/0'} at the opening of the channel (variable \texttt{a}
is related to the channel account number between the client and the provider as
shown in the paper). Then the index \texttt{i} in the paper is used to derive
each address without requiring any communication. It is worth noting that the
root derivation path can also be simplified at \texttt{m/a'} or even \texttt{m/}
because the compatibility with a standard wallet is no longer a requirement.
Noted that the version \texttt{m/a'} is more flexible and allows multiple
channels between a client and a provider with only one threshold key.

\subsection{Proof-of-concept implementation}

A proof-of-concept implemented in Python is made. A share can be tagged as
master share as previously described. The result of the script is presented
after that, three shares are created, and the first one is tagged as the master
share. The root threshold public key \texttt{m/} is computed and displayed, then
individual shares' addresses are displayed. The share $s_1$ is derived with and
without \textit{hardened} path, as expected the resulting address is different.
The master public key resulting from each share derivation for the path
\texttt{m/44/0/1} is the same as computing the private key with all individual
secret shares and getting the associated address, as expected. To note that only
the master individual address for \texttt{m/} and \texttt{m/44/0/1} has changed.

\begin{listing}
  \begin{minted}[breaklines=true,fontsize=\scriptsize]{text}
=== Threshold addresses ===
Master root public key m/   : 1BF5ZpQMCg3eGDEm51rkiwcKR12UnFu

*** Individual addresses m/ ***
s1: 1tRFxbAfKKowtqrSC3bVUi491hTXqg1
s2: 16uCytSc9oAJyi5FbxmH6NyTJuYkCLj
s3: 1TcYLZUZYd86AFaT58tzFGBW1BVVw7K

*** Hardened derivation for one share ***
s1 m/44/0/1  : 128PvDGSbZuNpz1zG1Mh1fjJFN3eNaTb
s1 m/44/0/1' : 12883vUsA2gyCAcSNogGUMFuCJsrj58

*** Master public key m/44/0/1 ***
s1: 128PvDGSbZuNpz1zG1Mh1fjJFN3eNaTb
s2: 128PvDGSbZuNpz1zG1Mh1fjJFN3eNaTb
s3: 128PvDGSbZuNpz1zG1Mh1fjJFN3eNaTb

Master public key m/44/0/1 : 128PvDGSbZuNpz1zG1Mh1fjJFN3eNaTb

*** Individual addresses m/44/0/1 ***
s1: 1nNL1gozCk4J1agV667kJFmsyu4RvF5
s2: 16uCytSc9oAJyi5FbxmH6NyTJuYkCLj
s3: 1TcYLZUZYd86AFaT58tzFGBW1BVVw7K
  \end{minted}
	\caption{Result of using threshold HD wallet}
	\label{lst:testThresholdHDMainRes}
\end{listing}

A share is composed of four main pieces of information: (i) the secret share, (ii) the
chain code, (iii) the tag for the master share, and (iv) the threshold public
key. Players can set the threshold public key address after computation. The
derive function \texttt{d} derives with \texttt{CKDpub} or \texttt{CKDpriv}
depending on the master tag and returns a new share for a given index. The path
derivation function \texttt{derive} takes a path and generates the chain of
shares. In this Implementation, if a share not tagged as master tries to derive a
path with a \texttt{hardened} index, an exception is raised, and the process
stops. However, in a real-world case, a communication process must take place to
complete the derivation.

\begin{listing}
  \pythonfile[firstline=252,lastline=295]{02-main/listings/address.py}
	\caption{Demonstration of using threshold HD wallet}
	\label{lst:testThresholdHDMain}
\end{listing}

\begin{listing}
  \pythonfile[firstline=163,lastline=230]{02-main/listings/address.py}
	\caption{Construction of a share for a threshold HD wallet}
	\label{lst:testThresholdHDShare}
\end{listing}


% -----------------------------------------------------------------------------
\section{Threshold deterministic signatures}

One of the simplest ways to compromise the private key in \gls{ecdsa}, or in
\gls{dsa}, is to select a weak pseudo-random number generator for $k$ or even
worse, select a static value for $k$. This problem already affected Sony in
December 2010 when a group of hackers calling itself \textit{fail0verflow}
announced the recovery of the \gls{ecdsa} private key used to sign software for
the PlayStation 3.

Given two signatures $(r, s)$ and $(r, s')$ employing the same unknown $k$ for
different messages $m$ and $m'$. Let's define $x$ as the private key, $z$ as the
hash of $m$ and $z'$ of $m'$, an attacker can calculate:

\begin{equation*}
\begin{split}
  s &\equiv k^{-1} (z + rx) \pmod n \\
  s' &\equiv k^{-1} (z' + rx) \pmod n \\
  s - s' &\equiv k^{-1} (z + rx) - k^{-1} (z' + rx) \pmod n \\
         &\equiv k^{-1} (z - z') \pmod n \\
  k &\equiv \frac{z - z'}{s - s'} \pmod n \\
  x &\equiv \frac{sk - z}{r} \pmod n
\end{split}
\end{equation*}

However, this issue can be prevented by a deterministic generation of $k$, as
described by RFC 6979 \cite{rfc6979}. The random value $k$ can be generated
deterministically by using a \texttt{HMAC} function such that the parameters are
the private key and the message to sign.

The other positive side is that signatures for the same key pair and the same
message are deterministic, i.e., if we sign the same message multiple times, the
signature remains the same. This determinism is also a significant advantage in
Bitcoin to reduce transaction malleability (nevertheless, the signer can still
choose to sign with non-deterministic nonce). The threshold scheme can also
enjoy the same properties through a deterministic signature system.

\begin{equation*}
\begin{split}
  k_1 &= \texttt{HMAC}(m, x_1) \\
  k_2 &= \texttt{HMAC}(m, x_2) \\
  k &= k_1k_2 \mod n
\end{split}
\end{equation*}

The values $k_1$ and $k_2$ remain secret as well as the value $x_1$ and $x_2$
but the signature will always be the same for the given message and threshold
key.
