\chapter{Implémentation de \og safe stack \fg}
\label{chap:implSafeStack4}


\cfile{02-main/listings/safeStack.cpp}
\captionof{listing}{Implémentation de la méthode IsSafeStackAlloca de \og safe stack \fg \label{lst:IsSafeStackAlloca}}


\cfile{02-main/listings/runOnFunction.cpp}
\captionof{listing}{Implémentation de la méthode runOnFunction de \og safe stack \fg \label{lst:runOnFunctionComplete}}

\begin{listing}
	\begin{minted}[linenos,firstnumber=97,breaklines=true,fontsize=\scriptsize]{c}
static inline void *unsafe_stack_alloc(size_t size, size_t guard) {
  CHECK_GE(size + guard, size);
  void *addr = MmapOrDie(size + guard, "unsafe_stack_alloc");
  MprotectNoAccess((uptr)addr, (uptr)guard);
  return (char *)addr + guard;
}

static inline void unsafe_stack_setup(void *start, size_t size, size_t guard) {
  CHECK_GE((char *)start + size, (char *)start);
  CHECK_GE((char *)start + guard, (char *)start);
  void *stack_ptr = (char *)start + size;
  CHECK_EQ((((size_t)stack_ptr) & (kStackAlign - 1)), 0);

  __safestack_unsafe_stack_ptr = stack_ptr;
  unsafe_stack_start = start;
  unsafe_stack_size = size;
  unsafe_stack_guard = guard;
}

static void unsafe_stack_free() {
  if (unsafe_stack_start) {
    UnmapOrDie((char *)unsafe_stack_start - unsafe_stack_guard,
               unsafe_stack_size + unsafe_stack_guard);
  }
  unsafe_stack_start = nullptr;
}
	\end{minted}
	\caption{Méthodes présentes dans la bibliothèque d'exécution de \og \gls{safeStack} \fg}
	\label{lst:safeStackRuntime}
\end{listing}
